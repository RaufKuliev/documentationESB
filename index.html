<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EventSummaryBot - Техническая документация</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #0088cc;
            --secondary-color: #00acc1;
            --bg-primary: #ffffff;
            --bg-secondary: #f5f7fa;
            --bg-sidebar: #1e293b;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-sidebar: #e2e8f0;
            --border-color: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --code-bg: #f1f5f9;
            --code-border: #cbd5e1;
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-sidebar: #0a0f1e;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-sidebar: #e2e8f0;
            --border-color: #334155;
            --code-bg: #1e293b;
            --code-border: #334155;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-secondary);
        }

        /* Layout */
        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background-color: var(--bg-sidebar);
            color: var(--text-sidebar);
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 24px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
            color: #fff;
        }

        .sidebar-subtitle {
            font-size: 13px;
            color: #94a3b8;
        }

        .nav-menu {
            padding: 16px 0;
        }

        .nav-section {
            margin-bottom: 24px;
        }

        .nav-section-title {
            padding: 8px 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .nav-item {
            display: block;
            padding: 10px 20px 10px 32px;
            color: var(--text-sidebar);
            text-decoration: none;
            font-size: 14px;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
            border-left-color: var(--primary-color);
        }

        .nav-item.active {
            background-color: rgba(0, 136, 204, 0.1);
            border-left-color: var(--primary-color);
            color: #fff;
            font-weight: 500;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            background-color: var(--bg-primary);
        }

        .content-header {
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .breadcrumb-current {
            color: var(--text-primary);
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: #0077b3;
            box-shadow: var(--shadow);
        }

        .btn-secondary {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background-color: var(--border-color);
        }

        /* Content Area */
        .content-area {
            padding: 40px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Typography */
        h1 {
            font-size: 36px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
            line-height: 1.2;
        }

        h2 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-top: 48px;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 32px;
            margin-bottom: 16px;
        }

        h4 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 24px;
            margin-bottom: 12px;
        }

        p {
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        /* Lists */
        ul, ol {
            margin-left: 24px;
            margin-bottom: 16px;
        }

        li {
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        /* Code */
        code {
            background-color: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #e11d48;
            border: 1px solid var(--code-border);
        }

        pre {
            background-color: var(--code-bg);
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 24px;
            border: 1px solid var(--code-border);
            box-shadow: var(--shadow);
        }

        pre code {
            background: none;
            padding: 0;
            border: none;
            color: var(--text-primary);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 24px;
            background-color: var(--bg-primary);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        thead {
            background-color: var(--bg-sidebar);
        }

        th {
            padding: 14px 16px;
            text-align: left;
            font-weight: 600;
            color: white;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        td {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        tr:last-child td {
            border-bottom: none;
        }

        tbody tr:hover {
            background-color: var(--bg-secondary);
        }

        /* Alert Boxes */
        .alert {
            padding: 16px 20px;
            border-radius: 8px;
            margin-bottom: 24px;
            border-left: 4px solid;
            display: flex;
            align-items: start;
            gap: 12px;
        }

        .alert-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .alert-info {
            background-color: #dbeafe;
            border-color: #0088cc;
            color: #1e40af;
        }

        .alert-success {
            background-color: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }

        .alert-warning {
            background-color: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }

        .alert-error {
            background-color: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
        }

        /* Search */
        .search-box {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .search-input {
            width: 100%;
            padding: 10px 16px 10px 40px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: rgba(255, 255, 255, 0.1);
        }

        .search-input::placeholder {
            color: #94a3b8;
        }

        /* Theme Toggle */
        .theme-toggle {
            background: none;
            border: none;
            color: var(--text-sidebar);
            cursor: pointer;
            font-size: 20px;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Print Styles */
        @media print {
            .sidebar,
            .content-header,
            .header-actions {
                display: none !important;
            }

            .main-content {
                padding: 0;
            }

            .section {
                display: block !important;
                page-break-before: always;
            }

            .section:first-child {
                page-break-before: avoid;
            }

            h2 {
                page-break-after: avoid;
            }

            pre, table {
                page-break-inside: avoid;
            }
        }

        /* Responsive - Mobile */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 85%;
                max-width: 320px;
                transform: translateX(-100%);
                box-shadow: 2px 0 10px rgba(0,0,0,0.3);
                z-index: 1001;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar-header {
                padding: 20px 16px;
            }

            .sidebar-title {
                font-size: 18px;
            }

            .sidebar-subtitle {
                font-size: 12px;
            }

            .nav-item {
                padding: 12px 16px 12px 24px;
                font-size: 15px;
            }

            .content-header {
                padding: 16px 20px;
                padding-left: 60px;
            }

            .breadcrumb {
                font-size: 13px;
            }

            .content-area {
                padding: 16px;
            }

            h1 {
                font-size: 24px !important;
                line-height: 1.3;
                margin-bottom: 16px !important;
            }

            h2 {
                font-size: 20px !important;
                margin-top: 28px !important;
                margin-bottom: 14px !important;
            }

            h3 {
                font-size: 18px !important;
                margin-top: 24px !important;
            }

            h4 {
                font-size: 16px !important;
            }

            p {
                font-size: 15px;
                line-height: 1.6;
            }

            /* Адаптивные таблицы */
            table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                font-size: 14px;
            }

            th, td {
                padding: 10px 12px;
                min-width: 100px;
            }

            /* Адаптивные code блоки */
            pre {
                font-size: 13px;
                padding: 14px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            code {
                font-size: 13px;
            }

            /* Списки */
            ul, ol {
                padding-left: 20px;
                font-size: 15px;
            }

            li {
                margin-bottom: 8px;
            }

            /* Кнопки */
            .header-actions button {
                padding: 8px 12px;
                font-size: 13px;
            }

            .export-btn {
                display: none;
            }

            /* Поиск */
            .search-box {
                padding: 12px;
            }

            .search-input {
                font-size: 15px;
                padding: 10px 12px;
            }
        }

        /* Mobile Overlay */
        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mobile-overlay.active {
            display: block;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .mobile-overlay {
                display: none;
            }
            
            .mobile-overlay.active {
                display: block;
            }
        }

        /* Extra Small Mobile */
        @media (max-width: 480px) {
            .sidebar {
                width: 90%;
            }

            .content-header {
                padding: 12px 16px;
                padding-left: 56px;
            }

            .breadcrumb {
                font-size: 12px;
            }

            .content-area {
                padding: 12px;
            }

            h1 {
                font-size: 22px !important;
            }

            h2 {
                font-size: 18px !important;
            }

            h3 {
                font-size: 16px !important;
            }

            p, li {
                font-size: 14px;
            }

            table {
                font-size: 13px;
            }

            th, td {
                padding: 8px 10px;
                min-width: 80px;
            }

            pre {
                font-size: 12px;
                padding: 12px;
            }

            .theme-toggle {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-new {
            background-color: #10b981;
            color: white;
        }

        .badge-updated {
            background-color: #0088cc;
            color: white;
        }

        /* Divider */
        hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: 40px 0;
        }

        /* Link Styles */
        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Blockquote */
        blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 20px;
            margin: 24px 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 136, 204, 0.4);
            z-index: 1002;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 136, 204, 0.5);
        }

        .menu-toggle:active {
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: flex;
            }
        }

        @media (max-width: 480px) {
            .menu-toggle {
                width: 48px;
                height: 48px;
                font-size: 20px;
                bottom: 16px;
                right: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">📚 EventSummaryBot</div>
                <div class="sidebar-subtitle">Техническая документация v1.0</div>
            </div>

            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="🔍 Поиск...">
            </div>

            <nav class="nav-menu">
                <div class="nav-section">
                    <div class="nav-section-title">Введение</div>
                    <a class="nav-item active" data-section="overview">📖 Обзор проекта</a>
                    <a class="nav-item" data-section="architecture">🏗️ Архитектура</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Данные</div>
                    <a class="nav-item" data-section="data-formats">📝 Форматы данных</a>
                    <a class="nav-item" data-section="prompts">🤖 Промпты и сценарии</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Приложение</div>
                    <a class="nav-item" data-section="mini-app">📱 Мини-приложение</a>
                    <a class="nav-item" data-section="use-cases">💡 Примеры использования</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Развертывание</div>
                    <a class="nav-item" data-section="error-handling">🐛 Обработка ошибок</a>
                    <a class="nav-item" data-section="deployment">🚀 Развертывание</a>
                    <a class="nav-item" data-section="scalability">📈 Масштабирование</a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content-header">
                <div class="breadcrumb">
                    <span>Документация</span>
                    <span>›</span>
                    <span class="breadcrumb-current" id="currentSection">Обзор проекта</span>
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary theme-toggle" id="themeToggle" title="Переключить тему">
                        🌓
                    </button>
                    <button class="btn btn-primary" onclick="window.print()">
                        📄 Печать / PDF
                    </button>
                </div>
            </div>

            <div class="content-area" id="contentArea">
                <!-- Sections will be loaded here dynamically -->
            </div>
        </main>
    </div>

    <!-- Mobile Menu Toggle -->
    <button class="menu-toggle" id="menuToggle">☰</button>
    <div class="mobile-overlay" id="mobileOverlay"></div>

    <script>
        // Content Data
        const sections = {
    'overview': {
        title: 'Обзор проекта',
        content: `<h1>1. Обзор проекта EventSummaryBot</h1><h2>1.1 Введение</h2><p><strong>EventSummaryBot</strong> — это комплексная система на базе Telegram Bot API, разработанная для автоматизации процесса создания сводок из аудиозаписей конференций, встреч и других мероприятий. Система использует современные технологии искусственного интеллекта для транскрибации аудио и генерации структурированных текстовых сводок.</p><h2>1.2 Цели проекта</h2><h3>Основные цели</h3><p><li><strong>Автоматизация транскрибации</strong> — преобразование аудиозаписей с конференций (Zoom и других источников) в текстовый формат с использованием технологии Whisper</li>
<li><strong>Генерация сводок</strong> — создание структурированных сводок различных типов с помощью AI-модели Anthropic Claude</li>
<li><strong>Управление балансом минут</strong> — предоставление пользователям удобного интерфейса для мониторинга использования и покупки минут транскрибации</li>
<li><strong>Интерактивное взаимодействие</strong> — возможность задавать вопросы по транскрибированному контенту через чат-бота</li></p><h3>Бизнес-задачи</h3><ul><li>Снижение времени на создание протоколов встреч и конспектов</li>
<li>Повышение качества документации событий</li>
<li>Обеспечение доступности информации для участников после мероприятия</li>
<li>Монетизация сервиса через систему покупки минут</li>
</ul>
<h2>1.3 Роль бота в экосистеме</h2><p>EventSummaryBot выполняет следующие ключевые функции:</p><h3>Для пользователей</h3><ul><li><strong>Приём аудиофайлов</strong> — загрузка записей конференций напрямую или через интеграцию с Zoom</li>
<li><strong>Выбор типа сводки</strong> — предоставление различных форматов вывода (отчёт, конспект, протокол встречи)</li>
<li><strong>Контроль баланса</strong> — отслеживание оставшихся минут и простая покупка дополнительных</li>
<li><strong>Интерактивное общение</strong> — возможность задавать вопросы по содержимому транскрибации</li>
</ul>
<h3>Для администраторов</h3><ul><li><strong>Мониторинг использования</strong> — детальная статистика по пользователям и платежам</li>
<li><strong>Управление новостями</strong> — публикация обновлений и анонсов для пользователей</li>
<li><strong>Контроль качества</strong> — модерация и утверждение сгенерированных сводок</li>
</ul>
<h2>1.4 Основные компоненты системы</h2><p>Система состоит из следующих ключевых компонентов:</p><p><li><strong>Telegram Bot</strong> — интерфейс взаимодействия с пользователями</li>
<li><strong>n8n Workflows</strong> — оркестрация бизнес-процессов и интеграций</li>
<li><strong>Whisper API</strong> — сервис транскрибации аудио в текст</li>
<li><strong>Anthropic Claude</strong> — генерация сводок и ответов на вопросы</li>
<li><strong>Flask Web Application</strong> — мини-приложение для управления балансом</li>
<li><strong>Google Sheets</strong> — хранилище данных пользователей и платежей</li>
<li><strong>YooKassa</strong> — платёжная система для покупки минут</li>
<li><strong>Google Docs/Drive</strong> — хранение транскрибаций и сводок</li></p><h2>1.5 Целевая аудитория документации</h2><p>Данная документация предназначена для:</p><h3>Технических менеджеров</h3><ul><li>Понимание архитектурных решений</li>
<li>Оценка масштабируемости и рисков</li>
<li>Планирование развития системы</li>
</ul>
<h3>Разработчиков</h3><ul><li>Детальные инструкции по настройке</li>
<li>Примеры конфигураций</li>
<li>Рекомендации по расширению функционала</li>
</ul>
<h3>DevOps инженеров</h3><ul><li>Процесс развертывания</li>
<li>Конфигурация инфраструктуры</li>
<li>Мониторинг и обслуживание</li>
</ul>
<h2>1.6 Ключевые преимущества решения</h2><p><li><strong>Низкая барьерность входа</strong> — Telegram-интерфейс не требует установки дополнительных приложений</li>
<li><strong>Гибкость обработки</strong> — поддержка различных типов контента и форматов сводок</li>
<li><strong>Прозрачная монетизация</strong> — понятная поминутная тарификация</li>
<li><strong>Масштабируемость</strong> — архитектура позволяет обрабатывать большое количество запросов</li>
<li><strong>Интеграции</strong> — готовые коннекторы к популярным сервисам (Zoom, Google Drive)</li></p><h2>1.7 Технологический стек</h2><table>
<thead><tr><th>Компонент</th><th>Технология</th><th>Роль</th></tr></thead>
<tbody>
<tr><td>Оркестрация</td><td>n8n</td><td>Координация workflow и интеграций</td></tr>
<tr><td>Backend</td><td>Flask (Python)</td><td>REST API для мини-приложения</td></tr>
<tr><td>Frontend</td><td>HTML/CSS/JavaScript</td><td>Интерфейс мини-приложения</td></tr>
<tr><td>База данных</td><td>Google Sheets</td><td>Хранение пользователей и транзакций</td></tr>
<tr><td>AI Транскрибация</td><td>Whisper</td><td>Преобразование аудио в текст</td></tr>
<tr><td>AI Генерация</td><td>Anthropic Claude 3.7 Sonnet</td><td>Создание сводок</td></tr>
<tr><td>Платежи</td><td>YooKassa</td><td>Обработка оплаты</td></tr>
<tr><td>Хранилище</td><td>Google Drive/Docs</td><td>Файлы и документы</td></tr>
<tr><td>Messenger</td><td>Telegram Bot API</td><td>Интерфейс пользователя</td></tr>
</tbody></table><h2>1.8 Метрики успеха</h2><p>Эффективность системы оценивается по следующим метрикам:</p><ul><li><strong>Скорость обработки</strong> — время от загрузки аудио до получения сводки</li>
<li><strong>Точность транскрибации</strong> — качество распознавания речи</li>
<li><strong>Удовлетворённость пользователей</strong> — качество сгенерированных сводок</li>
<li><strong>Доступность сервиса</strong> — uptime системы (целевой показатель 99.5%)</li>
<li><strong>Конверсия</strong> — процент пользователей, совершивших покупку минут</li>
</ul>`
    },
    'architecture': {
        title: 'Архитектура системы',
        content: `<h1>2. Архитектура системы EventSummaryBot</h1><h2>2.1 Общая архитектура</h2><h3>2.1.1 Высокоуровневая схема</h3><pre><code class="language-">┌─────────────────────────────────────────────────────────────────────┐
│                          ПОЛЬЗОВАТЕЛИ                               │
│  (Telegram клиенты на мобильных устройствах и десктопах)            │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      TELEGRAM BOT API                               │
│                   (EventSummaryBot)                                 │
└────────────┬────────────────────────────┬───────────────────────────┘
             │                            │
             ▼                            ▼
┌────────────────────────┐    ┌──────────────────────────────────────┐
│   n8n WORKFLOWS        │    │  FLASK WEB APPLICATION               │
│   (Оркестрация)        │    │  (Мини-приложение)                   │
│                        │    │                                      │
│  • Zoom_main           │    │  • REST API                          │
│  • askaudio            │    │  • Управление пользователями         │
│  • generation_svodka   │    │  • Платежи                           │
│  • webhooks            │    │  • Статистика                        │
└────┬─────────┬─────────┘    └─────┬──────────────┬─────────────────┘
     │         │                    │              │
     │         └────────────────────┼──────┐       │
     │                              │      │       │
     ▼                              ▼      ▼       ▼
┌──────────────┐           ┌─────────────────────────────────────────┐
│   WHISPER    │           │       GOOGLE SERVICES                   │
│   (Audio→    │           │  • Google Sheets (БД)                   │
│   Text)      │           │  • Google Drive (Файлы)                 │
└──────────────┘           │  • Google Docs (Транскрибации)          │
                           └─────────────────────────────────────────┘
     ▼                              
┌──────────────┐                   ┌─────────────────────────────────┐
│  ANTHROPIC   │                   │        YOOKASSA                 │
│  CLAUDE 3.7  │                   │   (Платёжный шлюз)              │
│  (Генерация  │                   └─────────────────────────────────┘
│   сводок)    │                   
└──────────────┘                   ┌─────────────────────────────────┐
                                   │         ZOOM API                │
                                   │   (Получение записей)           │
                                   └─────────────────────────────────┘
</code></pre><h2>2.2 Компонентная архитектура</h2><h3>2.2.1 Telegram Bot (Точка входа)</h3><p><strong>Назначение:</strong> Единая точка взаимодействия пользователя с системой</p><p><strong>Функциональность:</strong>
<ul><li>Приём команд от пользователей</li>
<li>Отправка уведомлений и результатов</li>
<li>Управление интерактивными кнопками (inline keyboard)</li>
<li>Приём аудиофайлов и голосовых сообщений</li>
</ul>
<strong>Технологии:</strong> Telegram Bot API v6+</p><p><strong>Интеграции:</strong>
<ul><li>Webhook-подписки для обработки событий</li>
<li>Двусторонняя коммуникация с n8n workflows</li>
</ul>
<h3>2.2.2 n8n Workflows (Центральная оркестрация)</h3><p><strong>Назначение:</strong> Координация бизнес-процессов и интеграция внешних сервисов</p><h4>Основные workflow:</h4><p>##### 1. Zoom_main
<strong>Файл:</strong> <code>Zoom_main.json</code></p><p><strong>Назначение:</strong> Обработка новых записей с Zoom</p><p><strong>Последовательность шагов:</strong>
<li><strong>Webhook</strong> — получение события от Zoom о завершении записи</li>
<li><strong>Получение метаданных</strong> — извлечение информации о конференции</li>
<li><strong>Скачивание аудио</strong> — загрузка файла записи</li>
<li><strong>Вызов Whisper</strong> — транскрибация через подчиненный workflow</li>
<li><strong>Сохранение в Google Docs</strong> — создание документа с транскрибацией</li>
<li><strong>Формирование периода</strong> — расчет длительности конференции</li>
<li><strong>Рассылка уведомлений</strong> — отправка сообщений ответственным лицам</li>
<li><strong>Предложение создать сводку</strong> — inline-кнопки для выбора действия</li></p><p><strong>Ключевые узлы:</strong>
<ul><li><code>Webhook</code> — точка входа (POST endpoint)</li>
<li><code>Whsiper Workflow</code> — вызов подчиненного workflow для транскрибации</li>
<li><code>System Pr0mt</code> — загрузка системного промпта из Google Docs</li>
<li><code>Рассылка отв лицам</code> — выборка получателей из Google Sheets</li>
</ul>
##### 2. generation_svodka_audio
<strong>Файл:</strong> <code>generation_svodka_audio.json</code></p><p><strong>Назначение:</strong> Генерация различных типов сводок</p><p><strong>Типы сводок (Switch node):</strong>
<ul><li><code>HybridAudio</code> — гибридный формат (лекция + обсуждение)</li>
<li><code>LectureAudio</code> — конспект лекции</li>
<li><code>ReportAudio</code> — отчёт о встрече</li>
<li><code>MeetingAudio</code> — протокол собрания</li>
<li><code>KonspektAudio</code> — детальный конспект</li>
</ul>
<strong>Последовательность:</strong>
<li><strong>Switch_prompt audio</strong> — выбор промпта по callback_data</li>
<li><strong>Merge prompt</strong> — объединение системного промпта и транскрибации</li>
<li><strong>ИИ для создания сводки</strong> — вызов Anthropic Claude</li>
<li><strong>RAG_FOR_Zoom</strong> — доступ к контекстным документам (Google Drive Tool)</li>
<li><strong>Сохранение результата</strong> — запись сводки в Google Docs</li>
<li><strong>Отправка пользователю</strong> — через Telegram</li></p><p>##### 3. askaudio
<strong>Файл:</strong> <code>askaudio.json</code></p><p><strong>Назначение:</strong> Интерактивное общение с контентом транскрибации</p><p><strong>Последовательность:</strong>
<li><strong>When Executed by Another Workflow</strong> — триггер от основного workflow</li>
<li><strong>Полная транскрибация</strong> — загрузка последней транскрибации из Google Drive</li>
<li><strong>Берет ласт актуальную сводку</strong> — сортировка по дате создания</li>
<li><strong>Берет самую ласт сводку</strong> — получение содержимого Google Doc</li>
<li><strong>ask_audio (Agent)</strong> — LLM агент с системным промптом</li>
<li><strong>Anthropic Chat Model 3.7</strong> — модель для генерации ответов</li>
<li><strong>Ответ от GPT</strong> — отправка ответа пользователю</li></p><p><strong>Системный промпт:</strong>
<pre><code class="language-">Ты — помощник, который отвечает СОГЛАСНО данному тексту транскрибации.
Не добавляй новых фактов и не уходи от темы.
Отвечай чётко и понятно, опираясь только на транскрибацию.
</code></pre><p>##### 4. Вспомогательные workflows</p><ul><li><strong>get_file_audio</strong> — получение файла для дополнительного анализа</li>
<li><strong>get_text_audio</strong> — обработка текстовых дополнений к сводке</li>
<li><strong>getfile_for_svodka</strong> — подготовка данных для генерации</li>
<li><strong>Perehod_obshenie_gpt_audio</strong> — переключение в режим общения (аудио)</li>
<li><strong>Perehod_obshenie_gpt_ZOOM</strong> — переключение в режим общения (Zoom)</li>
<li><strong>Podpiska_webhooks</strong> — управление подписками на события</li>
<li><strong>QUE</strong> — очередь обработки запросов</li>
</ul>
<h3>2.2.3 Flask Web Application (Мини-приложение)</h3><p><strong>Назначение:</strong> Web-интерфейс для управления балансом и статистикой</p><h4>Структура приложения</h4><pre><code class="language-">eventsummarybotsite/
├── main.py                 # Точка входа приложения
├── wsgi.py                 # WSGI сервер для продакшена
├── requirements.txt        # Зависимости Python
├── Dockerfile              # Контейнеризация
├── docker-compose.yml      # Оркестрация контейнеров
│
├── app/
│   ├── __init__.py
│   ├── config/             # Конфигурация
│   │   └── google_sheets.py
│   ├── controllers/        # Бизнес-логика
│   │   ├── admin_controller.py
│   │   ├── auth_controller.py
│   │   ├── news_controller.py
│   │   ├── payment_controller.py
│   │   └── user_controller.py
│   ├── middleware/         # Промежуточные обработчики
│   │   ├── auth_middleware.py
│   │   └── error_handler.py
│   ├── models/             # Модели данных
│   │   ├── admin_user.py
│   │   ├── news.py
│   │   └── payment.py
│   ├── routes/             # API маршруты
│   │   ├── admin.py
│   │   ├── auth.py
│   │   ├── news.py
│   │   ├── payments.py
│   │   └── users.py
│   ├── services/           # Сервисы
│   │   ├── admin_auth_service.py
│   │   ├── admin_service.py
│   │   ├── news_service.py
│   │   ├── payment_history_service.py
│   │   ├── payment_service.py
│   │   └── user_service.py
│   └── utils/              # Утилиты
│       ├── logger.py
│       └── validation.py
│
└── frontend/               # Статические файлы
    ├── index.html          # Главная страница
    ├── admin.html          # Админ-панель
    ├── admin-login.html    # Авторизация админа
    ├── app.js              # Клиентская логика
    ├── admin.js
    ├── style.css
    └── nginx.conf          # Конфигурация Nginx
</code></pre><h4>REST API Endpoints</h4><p>##### Пользователи
<ul><li><code>POST /api/users/login</code> — авторизация пользователя</li>
<li><code>GET /api/users/:chatid</code> — получение данных пользователя</li>
</ul>
##### Платежи
<ul><li><code>POST /api/payments/create</code> — создание платежа</li>
<li><code>POST /api/payments/webhook</code> — webhook от YooKassa</li>
<li><code>GET /api/payments/:paymentId/status</code> — статус платежа</li>
<li><code>GET /api/payments/user/:chatid</code> — история платежей пользователя</li>
<li><code>GET /api/payments</code> — все платежи (админ)</li>
<li><code>GET /api/payments/stats</code> — статистика платежей</li>
</ul>
##### Администрирование
<ul><li><code>GET /api/admin/users</code> — список пользователей</li>
<li><code>GET /api/admin/users/search</code> — поиск пользователей</li>
<li><code>GET /api/admin/users/top</code> — топ пользователей</li>
<li><code>GET /api/admin/stats/users</code> — статистика пользователей</li>
<li><code>GET /api/admin/stats</code> — общая статистика</li>
</ul>
##### Новости
<ul><li><code>GET /api/news</code> — все новости</li>
<li><code>GET /api/news/latest</code> — последние новости</li>
<li><code>GET /api/news/:newsId</code> — конкретная новость</li>
<li><code>POST /api/news</code> — создание новости (админ)</li>
<li><code>PUT /api/news/:newsId</code> — обновление новости</li>
<li><code>DELETE /api/news/:newsId</code> — удаление новости</li>
</ul>
##### Аутентификация
<ul><li><code>POST /api/auth/login</code> — вход администратора</li>
<li><code>POST /api/auth/logout</code> — выход</li>
<li><code>GET /api/auth/me</code> — текущий пользователь</li>
<li><code>POST /api/auth/admins</code> — создание админа</li>
<li><code>GET /api/auth/admins</code> — список администраторов</li>
</ul>
<h3>2.2.4 Внешние сервисы</h3><h4>Whisper (Транскрибация)</h4><p><strong>Назначение:</strong> Преобразование аудио в текст</p><p><strong>Параметры:</strong>
<ul><li><code>model_name</code>: <code>large-v2</code> — используемая модель</li>
<li><code>initial_prompt</code>: опциональный контекст для улучшения качества</li>
<li><code>upgrade_transcribation</code>: флаг улучшенной транскрибации</li>
<li>Форматы: MP3, M4A, WAV, FLAC</li>
</ul>
<strong>Интеграция:</strong> Через HTTP Request в n8n workflow</p><h4>Anthropic Claude (AI Генерация)</h4><p><strong>Модель:</strong> Claude 3.7 Sonnet (<code>claude-3-7-sonnet-20250219</code>)</p><p><strong>Использование:</strong>
<ul><li>Генерация сводок различных типов</li>
<li>Ответы на вопросы по транскрибации</li>
<li>Обработка дополнительных материалов</li>
</ul>
<strong>Особенности:</strong>
<ul><li>Системный промпт загружается из Google Docs</li>
<li>RAG (Retrieval-Augmented Generation) через Google Drive Tool</li>
<li>Удаление Markdown-разметки из ответов</li>
</ul>
<h4>Google Services</h4><p><strong>Google Sheets:</strong>
<ul><li>Хранение пользователей (chatid, username, minutes_total, minutes_used, minutes_left)</li>
<li>История платежей (payment_id, chatid, minutes, price, status, timestamps)</li>
<li>Список администраторов</li>
</ul>
<strong>Google Drive:</strong>
<ul><li>Папки с транскрибациями</li>
<li>RAG документы для контекста</li>
<li>Дополнительные файлы пользователей</li>
</ul>
<strong>Google Docs:</strong>
<ul><li>Системные промпты для различных сценариев</li>
<li>Сохраненные транскрибации</li>
<li>Итоговые сводки</li>
</ul>
<h4>YooKassa (Платежи)</h4><p><strong>Функции:</strong>
<ul><li>Создание платежей</li>
<li>Webhook уведомления о статусе</li>
<li>Поддержка различных методов оплаты</li>
</ul>
<strong>Тарифы:</strong>
<ul><li>100 минут — 299₽</li>
<li>200 минут — 549₽ (популярный)</li>
<li>500 минут — 1299₽</li>
</ul>
<h2>2.3 Потоки данных</h2><h3>2.3.1 Обработка Zoom записи</h3><pre><code class="language-">1. Zoom → Webhook → n8n (Zoom_main)
<li>n8n → Zoom API → Загрузка MP3</li>
<li>n8n → Whisper → Транскрибация</li>
<li>n8n → Google Docs → Сохранение транскрибации</li>
<li>n8n → Google Sheets → Получение списка получателей</li>
<li>n8n → Telegram Bot → Уведомление пользователей</li>
</code></pre><h3>2.3.2 Генерация сводки</h3><pre><code class="language-">1. Telegram Bot → Callback Query → n8n (generation_svodka_audio)
<li>n8n → Switch → Выбор типа сводки</li>
<li>n8n → Google Drive → Получение RAG документов</li>
<li>n8n → Google Docs → Загрузка промпта</li>
<li>n8n → Anthropic Claude → Генерация сводки</li>
<li>n8n → Google Docs → Сохранение сводки</li>
<li>n8n → Telegram Bot → Отправка пользователю</li>
</code></pre><h3>2.3.3 Покупка минут</h3><pre><code class="language-">1. User → Telegram Web App → Flask API
<li>Flask → YooKassa → Создание платежа</li>
<li>User → YooKassa → Оплата</li>
<li>YooKassa → Flask Webhook → Уведомление</li>
<li>Flask → Google Sheets → Обновление баланса</li>
<li>Flask → Telegram Bot → Уведомление о пополнении</li>
</code></pre><h2>2.4 Управление состоянием</h2><h3>Сессии пользователей</h3><p><strong>Telegram:</strong> Используется механизм callback_data для сохранения контекста</p><p><strong>Flask:</strong> JWT токены для мини-приложения (опционально, в текущей версии используется chatid)</p><h3>Данные пользователей</h3><p><strong>Хранение:</strong> Google Sheets</p><p><strong>Структура:</strong>
<pre><code class="language-">Sheet: "Users"
Columns: chatid | username | minutes_total | minutes_used | minutes_left
</code></pre><p><strong>Обновление баланса:</strong>
<ul><li>Добавление минут: <code>minutes_total += purchased, minutes_left += purchased</code></li>
<li>Списание минут: <code>minutes_used += duration, minutes_left -= duration</code></li>
</ul>
<h3>История транзакций</h3><p><strong>Хранение:</strong> Google Sheets (отдельный лист "Payments")</p><p><strong>Структура:</strong>
<pre><code class="language-">payment_id | chatid | username | minutes | price | status | 
created_at | updated_at | yookassa_payment_id | payment_method | description
</code></pre><h2>2.5 Безопасность на архитектурном уровне</h2><h3>Аутентификация</h3><ul><li><strong>Telegram Bot:</strong> Встроенная аутентификация Telegram (chatid)</li>
<li><strong>Flask API:</strong> JWT токены (опционально) + проверка chatid</li>
<li><strong>Администраторы:</strong> Bcrypt хеширование паролей</li>
</ul>
<h3>Авторизация</h3><ul><li><strong>Пользователи:</strong> Доступ только к своим данным (проверка chatid)</li>
<li><strong>Администраторы:</strong> Отдельная таблица с правами доступа</li>
</ul>
<h3>Защита API</h3><ul><li><strong>CORS:</strong> Ограничение разрешенных источников</li>
<li><strong>Rate Limiting:</strong> В планах (рекомендуется для production)</li>
<li><strong>HTTPS:</strong> Обязательно для production</li>
</ul>
<h3>Защита данных</h3><ul><li><strong>Google API:</strong> Service Account с ограниченными правами</li>
<li><strong>Приватные ключи:</strong> Хранение в переменных окружения</li>
<li><strong>YooKassa:</strong> Webhook signature verification</li>
</ul>`
    },
    'data-formats': {
        title: 'Форматы данных',
        content: `<h1>3. Форматы данных</h1><h2>3.1 Аудиоформаты</h2><h3>3.1.1 Поддерживаемые форматы</h3><p>EventSummaryBot поддерживает следующие аудиоформаты для транскрибации:</p><table>
<thead><tr><th>Формат</th><th>Расширение</th><th>MIME Type</th><th>Максимальный размер</th><th>Рекомендуется</th></tr></thead>
<tbody>
<tr><td>MP3</td><td>.mp3</td><td>audio/mpeg</td><td>50 MB</td><td>✅ Да</td></tr>
<tr><td>M4A</td><td>.m4a</td><td>audio/mp4</td><td>50 MB</td><td>✅ Да</td></tr>
<tr><td>WAV</td><td>.wav</td><td>audio/wav</td><td>100 MB</td><td>⚠️ Большой размер</td></tr>
<tr><td>FLAC</td><td>.flac</td><td>audio/flac</td><td>100 MB</td><td>⚠️ Большой размер</td></tr>
<tr><td>OGG</td><td>.ogg</td><td>audio/ogg</td><td>50 MB</td><td>✅ Да</td></tr>
</tbody></table><h3>3.1.2 Технические требования</h3><p><strong>Рекомендуемые параметры аудио:</strong>
<ul><li>Битрейт: минимум 64 kbps, рекомендуется 128 kbps</li>
<li>Частота дискретизации: 16 kHz или выше (рекомендуется 44.1 kHz)</li>
<li>Каналы: моно или стерео</li>
<li>Длительность: до 4 часов в одном файле</li>
</ul>
<strong>Обработка в n8n:</strong></p><pre><code class="language-javascript">// Пример подготовки файла для Whisper
items[0].binary.data.fileName = 'voice.mp3';
items[0].binary.data.fileExtension = 'mp3';
items[0].binary.data.mimeType = 'audio/mpeg';</p><p>items[0].json.model_name = 'large-v2';
items[0].json.initial_prompt = '';
items[0].json.upgrade_transcribation = 'false';
items[0].json.up_speed = '1';
</code></pre><h3>3.1.3 Структура бинарных данных в n8n</h3><pre><code class="language-json">{
  "binary": {
    "data": {
      "fileName": "recording_2025-10-24.mp3",
      "fileExtension": "mp3",
      "mimeType": "audio/mpeg",
      "fileSize": 15728640,
      "data": "BASE64_ENCODED_CONTENT"
    }
  },
  "json": {
    "model_name": "large-v2",
    "initial_prompt": "",
    "upgrade_transcribation": "false",
    "up_speed": "1",
    "id": "meeting-12345",
    "recording_start": "2025-10-24T10:00:00Z",
    "recording_end": "2025-10-24T11:30:00Z"
  }
}
</code></pre><h2>3.2 Текстовые форматы</h2><h3>3.2.1 Формат транскрибации</h3><p><strong>Структура вывода Whisper:</strong></p><pre><code class="language-">[Временная метка начала конференции: 2025-10-24 10:00:00]</p><p>Спикер 1: Добрый день, коллеги. Начинаем нашу еженедельную встречу...</p><p>Спикер 2: Спасибо за приглашение. Хотел бы обсудить...</p><p>...</p><p>[Длительность: 01:30:45]
</code></pre><p><strong>Метаданные транскрибации:</strong></p><pre><code class="language-json">{
  "content": "Полный текст транскрибации...",
  "metadata": {
    "duration": "01:30:45",
    "recording_start": "2025-10-24T10:00:00Z",
    "recording_end": "2025-10-24T11:30:45Z",
    "model": "whisper-large-v2",
    "language": "ru",
    "confidence": 0.92
  }
}
</code></pre><h3>3.2.2 Форматы сводок</h3><p>Система поддерживает 5 типов сводок, каждый с уникальной структурой:</p><h4>1. Hybrid (Гибридный)</h4><p><strong>Callback Data:</strong> <code>HybridAudio</code></p><p><strong>Структура:</strong></p><pre><code class="language-">СВОДКА ВСТРЕЧИ</p><p>Дата: [дата]
Длительность: [время]</p><p>ОСНОВНЫЕ ТЕМЫ:
<li>[Тема 1]</li>
<li>[Тема 2]</li>
<li>[Тема 3]</li></p><p>КЛЮЧЕВЫЕ ОБСУЖДЕНИЯ:</p><p>[Тема 1]
<ul><li>Обсуждение: ...</li>
<li>Решение: ...</li>
<li>Ответственный: ...</li>
</ul>
[Тема 2]
<ul><li>Обсуждение: ...</li>
<li>Решение: ...</li>
<li>Ответственный: ...</li>
</ul>
ПРИНЯТЫЕ РЕШЕНИЯ:
• [Решение 1]
• [Решение 2]</p><p>ЗАДАЧИ:
□ [Задача 1] - Ответственный: [Имя] - Срок: [Дата]
□ [Задача 2] - Ответственный: [Имя] - Срок: [Дата]</p><p>СЛЕДУЮЩАЯ ВСТРЕЧА:
Дата: [дата]
Повестка: [темы]
</code></pre><h4>2. Lecture (Лекция)</h4><p><strong>Callback Data:</strong> <code>LectureAudio</code></p><p><strong>Структура:</strong></p><pre><code class="language-">КОНСПЕКТ ЛЕКЦИИ</p><p>Тема: [Название темы]
Лектор: [Имя лектора]
Дата: [дата]</p><p>I. ВВЕДЕНИЕ
   [Вводная часть]</p><p>II. ОСНОВНАЯ ЧАСТЬ</p><p>   2.1. [Раздел 1]
        - [Ключевая мысль 1]
        - [Ключевая мысль 2]
        
        Примеры:
        • [Пример 1]
        • [Пример 2]
   
   2.2. [Раздел 2]
        - [Ключевая мысль 1]
        - [Ключевая мысль 2]</p><p>III. ЗАКЛЮЧЕНИЕ
     [Выводы и итоги]</p><p>КЛЮЧЕВЫЕ ТЕРМИНЫ:
• [Термин 1]: [Определение]
• [Термин 2]: [Определение]</p><p>РЕКОМЕНДУЕМАЯ ЛИТЕРАТУРА:
<li>[Источник 1]</li>
<li>[Источник 2]</li>
</code></pre><h4>3. Report (Отчёт)</h4><p><strong>Callback Data:</strong> <code>ReportAudio</code></p><p><strong>Структура:</strong></p><pre><code class="language-">ОТЧЕТ О ВСТРЕЧЕ</p><p>Дата: [дата]
Участники: [список]
Продолжительность: [время]</p><p>ЦЕЛЬ ВСТРЕЧИ:
[Описание цели]</p><p>ПОВЕСТКА ДНЯ:
<li>[Пункт 1]</li>
<li>[Пункт 2]</li>
<li>[Пункт 3]</li></p><p>ДЕТАЛЬНОЕ ОБСУЖДЕНИЕ:</p><p>По пункту 1 - [Название]
Докладчик: [Имя]
Содержание: [Описание]
Вопросы и обсуждение: [Детали]
Решение: [Принятое решение]</p><p>По пункту 2 - [Название]
...</p><p>ИТОГОВЫЕ РЕШЕНИЯ:
<li>[Решение 1]</li>
   Обоснование: [Причины]
   Ответственный: [Имя]
   Срок: [Дата]</p><p><li>[Решение 2]</li>
   ...</p><p>СТАТИСТИКА:
• Запланированное время: [время]
• Фактическое время: [время]
• Количество участников: [число]
• Принято решений: [число]
</code></pre><h4>4. Meeting (Собрание)</h4><p><strong>Callback Data:</strong> <code>MeetingAudio</code></p><p><strong>Структура:</strong></p><pre><code class="language-">ПРОТОКОЛ СОБРАНИЯ</p><p>Дата: [дата]
Место: [место/онлайн]
Председатель: [Имя]
Секретарь: [Имя]</p><p>ПРИСУТСТВОВАЛИ:
<li>[ФИО] - [должность]</li>
<li>[ФИО] - [должность]</li>
...</p><p>ПОВЕСТКА ДНЯ:
<li>[Вопрос 1]</li>
<li>[Вопрос 2]</li>
<li>[Вопрос 3]</li></p><p>СЛУШАЛИ:</p><p><li>По первому вопросу:</li>
   ВЫСТУПИЛ: [ФИО]
   СУТЬ: [Краткое изложение]
   
   ВОПРОСЫ:
   [ФИО]: [Вопрос]
   [ФИО]: [Ответ]
   
   ПОСТАНОВИЛИ:
   [Текст решения]
   
   ГОЛОСОВАНИЕ:
   За: [число]
   Против: [число]
   Воздержались: [число]</p><p><li>По второму вопросу:</li>
   ...</p><p>РЕШИЛИ:
<li>[Решение 1]</li>
<li>[Решение 2]</li></p><p>Председатель: ____________ ([ФИО])
Секретарь: _____________ ([ФИО])
</code></pre><h4>5. Konspekt (Детальный конспект)</h4><p><strong>Callback Data:</strong> <code>KonspektAudio</code></p><p><strong>Структура:</strong></p><pre><code class="language-">ДЕТАЛЬНЫЙ КОНСПЕКТ</p><p>Событие: [Название]
Дата: [дата]
Время: [начало - конец]</p><p>══════════════════════════════════════════</p><p>[00:00:00 - 00:05:23] ВВЕДЕНИЕ</p><p>Спикер: [Имя]
Содержание:
<ul><li>[Тезис 1]</li>
<li>[Тезис 2]</li>
</ul>
Цитаты:
"[Важная цитата]"</p><p>──────────────────────────────────────────</p><p>[00:05:24 - 00:18:45] ОСНОВНАЯ ТЕМА 1</p><p>Спикер: [Имя]
Содержание:
<ul><li>[Подробное описание]</li>
</ul>  
  Подтемы:
  • [Подтема 1]
    - [Детали]
  • [Подтема 2]
    - [Детали]</p><p>Визуальные материалы:
[Описание демонстрируемых материалов]</p><p>Важные моменты:
⚠️ [Критически важная информация]</p><p>──────────────────────────────────────────</p><p>[00:18:46 - 00:35:12] ВОПРОСЫ И ОТВЕТЫ</p><p>Q: [Вопрос от участника]
A: [Ответ спикера]</p><p>Q: [Вопрос от участника]
A: [Ответ спикера]</p><p>──────────────────────────────────────────</p><p>КЛЮЧЕВЫЕ ВЫВОДЫ:
<li>[Вывод 1]</li>
<li>[Вывод 2]</li>
<li>[Вывод 3]</li></p><p>NEXT STEPS:
☐ [Действие 1]
☐ [Действие 2]
</code></pre><h2>3.3 Форматы API</h2><h3>3.3.1 REST API Responses</h3><p>Все API endpoints возвращают JSON в следующем формате:</p><p><strong>Успешный ответ:</strong></p><pre><code class="language-json">{
  "success": true,
  "data": {
    // Полезная нагрузка
  },
  "timestamp": "2025-10-24T14:30:00Z"
}
</code></pre><p><strong>Ответ с ошибкой:</strong></p><pre><code class="language-json">{
  "success": false,
  "error": "Описание ошибки",
  "error_code": "USER_NOT_FOUND",
  "timestamp": "2025-10-24T14:30:00Z"
}
</code></pre><h3>3.3.2 Формат пользователя</h3><pre><code class="language-json">{
  "chatid": "123456789",
  "username": "john_doe",
  "minutes_total": 500,
  "minutes_used": 120,
  "minutes_left": 380,
  "created_at": "2025-01-15T10:00:00Z",
  "last_activity": "2025-10-24T14:30:00Z"
}
</code></pre><h3>3.3.3 Формат платежа</h3><pre><code class="language-json">{
  "payment_id": "pay_abc123xyz",
  "chatid": "123456789",
  "username": "john_doe",
  "minutes": 200,
  "price": 549.00,
  "status": "succeeded",
  "created_at": "2025-10-24T14:00:00Z",
  "updated_at": "2025-10-24T14:02:30Z",
  "yookassa_payment_id": "2b5f7c9d-8a3e-4f1b-9c6d-7e8a2b4c5d6f",
  "payment_method": "bank_card",
  "description": "Покупка 200 минут"
}
</code></pre><h3>3.3.4 Формат новости</h3><pre><code class="language-json">{
  "news_id": "news_001",
  "title": "Новая функция в боте",
  "content": "Мы добавили возможность...",
  "image_url": "https://example.com/image.jpg",
  "created_at": "2025-10-24T12:00:00Z",
  "updated_at": "2025-10-24T12:00:00Z",
  "author": "admin",
  "is_published": true,
  "priority": "high"
}
</code></pre><h2>3.4 Форматы Webhook</h2><h3>3.4.1 Zoom Webhook</h3><p><strong>Endpoint:</strong> Настраивается в n8n (Zoom_main workflow)</p><p><strong>Формат события:</strong></p><pre><code class="language-json">{
  "event": "recording.completed",
  "event_ts": 1698150123456,
  "payload": {
    "account_id": "abc123",
    "object": {
      "id": "987654321",
      "uuid": "abcd1234-5678-efgh-ijkl-9876543210",
      "host_id": "host123",
      "topic": "Weekly Team Meeting",
      "type": 2,
      "start_time": "2025-10-24T10:00:00Z",
      "duration": 90,
      "timezone": "Europe/Moscow",
      "recording_files": [
        {
          "id": "file001",
          "recording_start": "2025-10-24T10:00:00Z",
          "recording_end": "2025-10-24T11:30:00Z",
          "file_type": "MP4",
          "file_extension": "MP4",
          "file_size": 157286400,
          "download_url": "https://zoom.us/rec/download/..."
        }
      ]
    }
  }
}
</code></pre><h3>3.4.2 YooKassa Webhook</h3><p><strong>Endpoint:</strong> <code>POST /api/payments/webhook</code></p><p><strong>Формат уведомления:</strong></p><pre><code class="language-json">{
  "type": "notification",
  "event": "payment.succeeded",
  "object": {
    "id": "2b5f7c9d-8a3e-4f1b-9c6d-7e8a2b4c5d6f",
    "status": "succeeded",
    "paid": true,
    "amount": {
      "value": "549.00",
      "currency": "RUB"
    },
    "created_at": "2025-10-24T14:00:00.000Z",
    "description": "Покупка 200 минут",
    "metadata": {
      "chatid": "123456789",
      "minutes": "200"
    },
    "payment_method": {
      "type": "bank_card",
      "id": "2b5f7c9d-8a3e-4f1b-9c6d",
      "saved": false,
      "title": "Bank card *4444"
    }
  }
}
</code></pre><h2>3.5 Google Sheets форматы</h2><h3>3.5.1 Таблица пользователей</h3><p><strong>Название листа:</strong> <code>Users</code> (или <code>sheet_id_users</code>)</p><table>
<thead><tr><th>chatid</th><th>username</th><th>minutes_total</th><th>minutes_used</th><th>minutes_left</th></tr></thead>
<tbody>
<tr><td>123456789</td><td>john_doe</td><td>500</td><td>120</td><td>380</td></tr>
<tr><td>987654321</td><td>jane_smith</td><td>200</td><td>50</td><td>150</td></tr>
</tbody></table><p><strong>Типы данных:</strong>
<ul><li><code>chatid</code>: string</li>
<li><code>username</code>: string</li>
<li><code>minutes_total</code>: integer (с возможностью десятичных для промежуточных расчётов)</li>
<li><code>minutes_used</code>: float (секунды конвертируются в минуты)</li>
<li><code>minutes_left</code>: integer</li>
</ul>
<h3>3.5.2 Таблица платежей</h3><p><strong>Название листа:</strong> <code>Payments</code> (или <code>payment_history</code>)</p><table>
<thead><tr><th>payment_id</th><th>chatid</th><th>username</th><th>minutes</th><th>price</th><th>status</th><th>created_at</th><th>updated_at</th><th>yookassa_payment_id</th><th>payment_method</th><th>description</th></tr></thead>
<tbody>
<tr><td>pay_001</td><td>123456789</td><td>john_doe</td><td>200</td><td>549</td><td>succeeded</td><td>2025-10-24T14:00:00Z</td><td>2025-10-24T14:02:30Z</td><td>2b5f7c9d...</td><td>bank_card</td><td>Покупка 200 минут</td></tr>
</tbody></table><p><strong>Статусы:</strong>
<ul><li><code>pending</code> — ожидание оплаты</li>
<li><code>succeeded</code> — успешно оплачено</li>
<li><code>failed</code> — ошибка оплаты</li>
<li><code>canceled</code> — отменено</li>
</ul>
<h2>3.6 Telegram форматы</h2><h3>3.6.1 Inline Keyboard</h3><pre><code class="language-json">{
  "inline_keyboard": [
    [
      {
        "text": "Да ✅",
        "callback_data": "yes"
      },
      {
        "text": "Нет ❌",
        "callback_data": "no"
      }
    ],
    [
      {
        "text": "Ссылка на транскрибацию 🎙️",
        "url": "https://docs.google.com/document/d/..."
      }
    ],
    [
      {
        "text": "Дополнить сводку 📝",
        "callback_data": "addfile"
      }
    ]
  ]
}
</code></pre><h3>3.6.2 Callback Query Data</h3><p><strong>Типы сводок:</strong>
<ul><li><code>HybridAudio</code> — гибридная сводка</li>
<li><code>LectureAudio</code> — конспект лекции</li>
<li><code>ReportAudio</code> — отчёт</li>
<li><code>MeetingAudio</code> — протокол собрания</li>
<li><code>KonspektAudio</code> — детальный конспект</li>
</ul>
<strong>Действия:</strong>
<ul><li><code>yes</code> — подтверждение создания сводки</li>
<li><code>no</code> — отказ</li>
<li><code>addfile</code> — дополнение сводки файлом</li>
</ul>
<h2>3.7 Валидация данных</h2><h3>3.7.1 Правила валидации</h3><p><strong>Chat ID:</strong>
<ul><li>Тип: string или integer</li>
<li>Формат: только цифры</li>
<li>Длина: 6-12 символов</li>
<li>Пример: <code>"123456789"</code></li>
</ul>
<strong>Minutes:</strong>
<ul><li>Тип: integer</li>
<li>Диапазон: 1-10000</li>
<li>Валидация: <code>minutes > 0 and minutes <= 10000</code></li>
</ul>
<strong>Price:</strong>
<ul><li>Тип: float</li>
<li>Диапазон: 0.01-100000.00</li>
<li>Формат: 2 знака после запятой</li>
<li>Валидация: <code>price > 0</code></li>
</ul>
<strong>Username:</strong>
<ul><li>Тип: string</li>
<li>Длина: 3-32 символа</li>
<li>Разрешённые символы: <code>a-zA-Z0-9_</code></li>
<li>Валидация: <code>^[a-zA-Z0-9_]{3,32}$</code></li>
</ul>
<strong>Payment Status:</strong>
<ul><li>Enum: <code>["pending", "succeeded", "failed", "canceled"]</code></li>
<li>Валидация: значение должно быть в списке</li>
</ul>
<h3>3.7.2 Обработка ошибок формата</h3><p>При получении некорректных данных система возвращает:</p><pre><code class="language-json">{
  "success": false,
  "error": "Validation error",
  "details": {
    "field": "minutes",
    "value": "-10",
    "constraint": "must be positive integer",
    "expected": "integer &gt; 0"
  }
}
</code></pre>`
    },
    'prompts': {
        title: 'Промпты и сценарии',
        content: `<h1>4. Промпты и сценарии использования</h1><h2>4.1 Системные промпты</h2><p>Система использует различные промпты в зависимости от выбранного пользователем сценария обработки транскрибации.</p><h3>4.1.1 Базовая структура промпта</h3><p>Все промпты следуют единой структуре:</p><pre><code class="language-">System Message:
[Инструкции для модели о стиле и формате вывода]
[Правила обработки транскрибации]</p><p>User Message:
[Текст транскрибации]
</code></pre><h3>4.1.2 Общие правила для всех промптов</h3><p>В начале каждого промпта указывается:</p><pre><code class="language-">НИКОГДА не начинай ответ с объяснений типа "Создаю отчет", 
"Анализирую транскрипцию" ни на каком языке.</p><p>Всегда удаляй MarkDown знаки такие как # ; * и так далее из output.
</code></pre><p>Это обеспечивает:
<ul><li>Прямое начало с содержимого сводки</li>
<li>Чистый текстовый формат без разметки</li>
<li>Готовый к отправке пользователю контент</li>
</ul>
<h2>4.2 Промпты по типам сводок</h2><h3>4.2.1 Hybrid (Гибридный формат)</h3><p><strong>Callback Data:</strong> <code>HybridAudio</code></p><p><strong>Системный промпт:</strong></p><pre><code class="language-">Ты — профессиональный помощник по созданию сводок.
Твоя задача — создать гибридную сводку на основе транскрибации.</p><p>ФОРМАТ СВОДКИ:</p><p>СВОДКА ВСТРЕЧИ</p><p>Дата: [извлеки из транскрибации]
Длительность: [извлеки из метаданных]</p><p>ОСНОВНЫЕ ТЕМЫ:
[Перечисли 3-5 главных тем, обсуждавшихся на встрече]</p><p>КЛЮЧЕВЫЕ ОБСУЖДЕНИЯ:
[Для каждой темы:
<ul><li>Краткое содержание обсуждения</li>
<li>Высказанные мнения</li>
<li>Принятое решение</li>
<li>Ответственный за выполнение]</li>
</ul>
ПРИНЯТЫЕ РЕШЕНИЯ:
[Список всех решений в формате маркированного списка]</p><p>ЗАДАЧИ:
[Список задач с указанием:
<ul><li>Описание задачи</li>
<li>Ответственный</li>
<li>Срок выполнения (если указан)]</li>
</ul>
СЛЕДУЮЩАЯ ВСТРЕЧА:
[Если упоминалась - дата и повестка]</p><p>ПРАВИЛА:
<li>Сохраняй структуру как указано выше</li>
<li>Используй только информацию из транскрибации</li>
<li>Не добавляй своих интерпретаций</li>
<li>Если какой-то раздел не применим - пропусти его</li>
<li>Извлекай конкретные имена, даты и цифры</li>
</code></pre><p><strong>Применение:</strong>
<ul><li>Еженедельные встречи команды</li>
<li>Статусные коллы</li>
<li>Планирование проектов</li>
<li>Обсуждения с распределением задач</li>
</ul>
<h3>4.2.2 Lecture (Конспект лекции)</h3><p><strong>Callback Data:</strong> <code>LectureAudio</code></p><p><strong>Системный промпт:</strong></p><pre><code class="language-">Ты — эксперт по созданию учебных конспектов.
Твоя задача — создать структурированный конспект лекции.</p><p>ФОРМАТ КОНСПЕКТА:</p><p>КОНСПЕКТ ЛЕКЦИИ</p><p>Тема: [извлеки основную тему]
Лектор: [если указан]
Дата: [если указана]</p><p>I. ВВЕДЕНИЕ
   [Вводная часть и цели лекции]</p><p>II. ОСНОВНАЯ ЧАСТЬ
   
   2.1. [Первый раздел]
        [Ключевые тезисы]
        
        Примеры:
        [Приведённые примеры]
   
   2.2. [Второй раздел]
        [Ключевые тезисы]
        
        Примеры:
        [Приведённые примеры]
   
   [Продолжай нумерацию разделов]</p><p>III. ЗАКЛЮЧЕНИЕ
     [Выводы и обобщения]</p><p>КЛЮЧЕВЫЕ ТЕРМИНЫ:
[Список важных терминов с определениями]</p><p>РЕКОМЕНДУЕМАЯ ЛИТЕРАТУРА:
[Если упоминалась]</p><p>ПРАВИЛА:
<li>Структурируй информацию по логическим разделам</li>
<li>Выделяй ключевые мысли каждого раздела</li>
<li>Сохраняй важные примеры и иллюстрации</li>
<li>Фиксируй определения терминов</li>
<li>Используй иерархическую нумерацию</li>
<li>Не добавляй информации, которой нет в лекции</li>
</code></pre><p><strong>Применение:</strong>
<ul><li>Образовательные лекции</li>
<li>Обучающие вебинары</li>
<li>Мастер-классы</li>
<li>Презентации продуктов</li>
</ul>
<h3>4.2.3 Report (Отчёт о встрече)</h3><p><strong>Callback Data:</strong> <code>ReportAudio</code></p><p><strong>Системный промпт:</strong></p><pre><code class="language-">Ты — специалист по составлению деловых отчётов.
Твоя задача — создать формальный отчёт о встрече.</p><p>ФОРМАТ ОТЧЁТА:</p><p>ОТЧЕТ О ВСТРЕЧЕ</p><p>Дата: [извлеки]
Участники: [перечисли всех]
Продолжительность: [укажи]</p><p>ЦЕЛЬ ВСТРЕЧИ:
[Сформулируй цель на основе содержания]</p><p>ПОВЕСТКА ДНЯ:
[Список обсуждённых вопросов]</p><p>ДЕТАЛЬНОЕ ОБСУЖДЕНИЕ:</p><p>По пункту 1 - [Название]
Докладчик: [Имя]
Содержание: [Подробное описание доклада]
Вопросы и обсуждение: [Заданные вопросы и ответы]
Решение: [Принятое решение по этому пункту]</p><p>[Повторить для каждого пункта повестки]</p><p>ИТОГОВЫЕ РЕШЕНИЯ:
<li>[Решение 1]</li>
   Обоснование: [Почему принято]
   Ответственный: [Имя]
   Срок: [Дата]</p><p>СТАТИСТИКА:
• Количество участников: [число]
• Запланированное время: [время]
• Фактическое время: [время]
• Принято решений: [число]</p><p>ПРАВИЛА:
<li>Сохраняй формальный деловой стиль</li>
<li>Детально описывай обсуждения по каждому пункту</li>
<li>Чётко формулируй решения и сроки</li>
<li>Указывай всех ответственных лиц</li>
<li>Будь объективен и точен</li>
</code></pre><p><strong>Применение:</strong>
<ul><li>Деловые встречи с клиентами</li>
<li>Переговоры с партнёрами</li>
<li>Совещания руководства</li>
<li>Официальные презентации</li>
</ul>
<h3>4.2.4 Meeting (Протокол собрания)</h3><p><strong>Callback Data:</strong> <code>MeetingAudio</code></p><p><strong>Системный промпт:</strong></p><pre><code class="language-">Ты — секретарь, составляющий официальные протоколы.
Твоя задача — создать формальный протокол собрания.</p><p>ФОРМАТ ПРОТОКОЛА:</p><p>ПРОТОКОЛ СОБРАНИЯ № [если есть]</p><p>Дата: [дата]
Место: [место проведения или "онлайн"]
Председатель: [ФИО]
Секретарь: [ФИО, если указан]</p><p>ПРИСУТСТВОВАЛИ:
[Список всех участников с должностями]</p><p>ПОВЕСТКА ДНЯ:
<li>[Вопрос 1]</li>
<li>[Вопрос 2]</li>
...</p><p>СЛУШАЛИ:</p><p><li>По первому вопросу:</li>
   ВЫСТУПИЛ: [ФИО]
   СУТЬ: [Краткое изложение выступления]
   
   ВОПРОСЫ:
   [ФИО]: [Вопрос]
   [ФИО выступавшего]: [Ответ]
   
   ПОСТАНОВИЛИ:
   [Текст решения]
   
   ГОЛОСОВАНИЕ:
   За: [число]
   Против: [число]
   Воздержались: [число]</p><p>[Повторить для каждого вопроса]</p><p>РЕШИЛИ:
[Итоговые решения собрания]</p><p>Председатель: ____________ ([ФИО])
Секретарь: _____________ ([ФИО])</p><p>ПРАВИЛА:
<li>Соблюдай строгий протокольный стиль</li>
<li>Используй формулировки "СЛУШАЛИ", "ВЫСТУПИЛ", "ПОСТАНОВИЛИ"</li>
<li>Фиксируй все выступления и вопросы</li>
<li>Указывай результаты голосования, если было</li>
<li>Сохраняй хронологию обсуждения</li>
</code></pre><p><strong>Применение:</strong>
<ul><li>Собрания совета директоров</li>
<li>Общие собрания участников</li>
<li>Заседания комиссий</li>
<li>Официальные советы</li>
</ul>
<h3>4.2.5 Konspekt (Детальный конспект)</h3><p><strong>Callback Data:</strong> <code>KonspektAudio</code></p><p><strong>Системный промпт:</strong></p><pre><code class="language-">Ты — профессиональный конспектолог.
Твоя задача — создать максимально детальный конспект с временными метками.</p><p>ФОРМАТ КОНСПЕКТА:</p><p>ДЕТАЛЬНЫЙ КОНСПЕКТ</p><p>Событие: [название]
Дата: [дата]
Время: [начало - конец]</p><p>══════════════════════════════════════════</p><p>[ЧЧ:ММ:СС - ЧЧ:ММ:СС] РАЗДЕЛ/ТЕМА</p><p>Спикер: [имя]
Содержание:
[Подробная фиксация всего сказанного]</p><p>Ключевые моменты:
• [Важный момент 1]
• [Важный момент 2]</p><p>Цитаты:
"[Дословная цитата, если важна]"</p><p>Визуальные материалы:
[Описание показанных слайдов/демонстраций]</p><p>Важные отметки:
⚠️ [Критически важная информация]
💡 [Интересная идея]
❓ [Вопрос для уточнения]</p><p>──────────────────────────────────────────</p><p>[Продолжай для каждого временного блока]</p><p>КЛЮЧЕВЫЕ ВЫВОДЫ:
[Основные выводы из всего мероприятия]</p><p>NEXT STEPS:
☐ [Действие 1]
☐ [Действие 2]</p><p>ПРАВИЛА:
<li>Разбивай контент на временные блоки по 5-15 минут</li>
<li>Максимально детально фиксируй содержание</li>
<li>Используй временные метки для навигации</li>
<li>Выделяй важные цитаты</li>
<li>Отмечай визуальные материалы</li>
<li>Используй эмодзи для быстрой навигации</li>
<li>Сохраняй хронологическую последовательность</li>
</code></pre><p><strong>Применение:</strong>
<ul><li>Длительные конференции</li>
<li>Многочасовые тренинги</li>
<li>Детальная документация событий</li>
<li>Контент для последующего изучения</li>
</ul>
<h2>4.3 Промпт для вопросов (askaudio)</h2><h3>4.3.1 Системный промпт</h3><pre><code class="language-">Ты — помощник, который отвечает СОГЛАСНО данному тексту транскрибации.</p><p>ПРАВИЛА:
<li>Используй ТОЛЬКО информацию из предоставленной транскрибации</li>
<li>Не добавляй новых фактов, которых нет в тексте</li>
<li>Не уходи от темы транскрибации</li>
<li>Если ответ на вопрос отсутствует в транскрибации, честно сообщи об этом</li>
<li>Отвечай чётко и понятно</li>
<li>Ссылайся на конкретные части транскрибации</li>
<li>Не обращай внимание на команду "/askaudio" в начале вопроса</li></p><p>ТЕКСТ ТРАНСКРИБАЦИИ:
[Полный текст транскрибации]</p><p>Теперь ответь на вопрос пользователя, основываясь только на этой транскрибации.
</code></pre><h3>4.3.2 Примеры использования</h3><p><strong>Пример 1:</strong>
<pre><code class="language-">User: Кто был ответственным за задачу по разработке?
Bot: Согласно транскрибации, ответственным за разработку был назначен 
Иван Петров. Это было озвучено в 15:23, когда обсуждался план спринта.
</code></pre><p><strong>Пример 2:</strong>
<pre><code class="language-">User: Какие сроки были установлены для проекта?
Bot: В транскрибации упоминаются следующие сроки:
• Завершение проектирования - 15 ноября
• Начало разработки - 20 ноября
• Первая демонстрация клиенту - 10 декабря
Эти даты были озвучены руководителем проекта в начале встречи.
</code></pre><p><strong>Пример 3:</strong>
<pre><code class="language-">User: Что говорилось о бюджете маркетинговой кампании?
Bot: К сожалению, в предоставленной транскрибации не обсуждался бюджет 
маркетинговой кампании. Возможно, этот вопрос был рассмотрен на другой встрече 
или обсуждался в частном порядке.
</code></pre><h2>4.4 RAG (Retrieval-Augmented Generation)</h2><h3>4.4.1 Настройка RAG</h3><p>Для улучшения качества сводок используется RAG с доступом к контекстным документам:</p><p><strong>Конфигурация в n8n:</strong>
<pre><code class="language-json">{
  "node": "googleDriveTool",
  "parameters": {
    "resource": "fileFolder",
    "filter": {
      "folderId": "RAG_Zhig_Dolina",
      "whatToSearch": "files"
    }
  }
}
</code></pre><p><strong>Типы контекстных документов:</strong>
<ul><li>Глоссарии специфичной терминологии</li>
<li>Предыдущие сводки для поддержания стиля</li>
<li>Шаблоны документов</li>
<li>Корпоративные стандарты оформления</li>
</ul>
<h3>4.4.2 Интеграция RAG в промпт</h3><pre><code class="language-">System Message:
[Основной промпт]</p><p>ДОПОЛНИТЕЛЬНЫЙ КОНТЕКСТ:
[Релевантные документы из RAG]</p><p>ОСНОВНАЯ ЗАДАЧА:
Используй дополнительный контекст для:
<li>Правильного употребления терминов</li>
<li>Соблюдения корпоративного стиля</li>
<li>Улучшения качества сводки</li>
</code></pre><h2>4.5 Динамическая загрузка промптов</h2><h3>4.5.1 Хранение в Google Docs</h3><p>Системные промпты хранятся в Google Docs для упрощения обновления без изменения workflow:</p><p><strong>Структура документа промпта:</strong>
<pre><code class="language-">[Название типа сводки]</p><p>System Message:
[Полный текст системного промпта]</p><p>---
Обновлено: [дата]
Версия: [номер версии]
</code></pre><p><strong>Загрузка в n8n:</strong>
<pre><code class="language-javascript">// Node: "System Pr0mt ( Zhig Dolina )"
{
  "operation": "get",
  "documentURL": "https://docs.google.com/document/d/[DOCUMENT_ID]/edit"
}
</code></pre><h3>4.5.2 Преимущества подхода</h3><p><li><strong>Быстрое обновление</strong> — изменение промпта без перезапуска workflow</li>
<li><strong>Версионность</strong> — история изменений в Google Docs</li>
<li><strong>Совместная работа</strong> — несколько людей могут улучшать промпты</li>
<li><strong>A/B тестирование</strong> — легко переключаться между вариантами</li>
<li><strong>Документация</strong> — промпты служат документацией процесса</li></p><h2>4.6 Оптимизация промптов</h2><h3>4.6.1 Лучшие практики</h3><p><li><strong>Чёткие инструкции:</strong></li>
   - Используй императивные формулировки
   - Избегай двусмысленности
   - Приводи примеры желаемого формата</p><p><li><strong>Ограничения:</strong></li>
   - Явно указывай, что делать нельзя
   - Определяй границы творчества модели
   - Предотвращай галлюцинации</p><p><li><strong>Структурированность:</strong></li>
   - Используй разделы и заголовки
   - Применяй нумерацию и маркеры
   - Создавай визуальную иерархию</p><p><li><strong>Контекст:</strong></li>
   - Предоставляй необходимый background
   - Используй RAG для специфичного контекста
   - Учитывай предыдущие взаимодействия</p><h3>4.6.2 Метрики качества промптов</h3><p><strong>Оценка эффективности:</strong>
<ul><li>Точность извлечения информации (>95%)</li>
<li>Соблюдение формата (100%)</li>
<li>Отсутствие галлюцинаций (<1%)</li>
<li>Удовлетворённость пользователей (>4.5/5)</li>
</ul>
<strong>Процесс улучшения:</strong>
<li>Сбор обратной связи от пользователей</li>
<li>Анализ проблемных случаев</li>
<li>Итеративное улучшение промптов</li>
<li>A/B тестирование изменений</li>
<li>Внедрение лучшей версии</li></p><h2>4.7 Сценарии использования промптов</h2><h3>4.7.1 Выбор типа сводки</h3><p><strong>Блок-схема принятия решения:</strong></p><pre><code class="language-">Начало → Тип контента?
         ├─ Образовательный → Lecture
         ├─ Рабочая встреча → Hybrid или Meeting
         │   └─ Формальная? → Meeting
         │   └─ Обычная? → Hybrid
         ├─ Деловые переговоры → Report
         ├─ Длительное событие → Konspekt
         └─ Официальное собрание → Meeting
</code></pre><h3>4.7.2 Кастомизация промптов</h3><p>Пользователи могут дополнять промпт через команду "Дополнить сводку":</p><p><strong>Пример дополнения:</strong>
<pre><code class="language-">User отправляет файл с инструкцией:
"Обрати особое внимание на обсуждение бюджета 
и выдели все цифры в отдельный раздел"</p><p>Система добавляет к основному промпту:
"ДОПОЛНИТЕЛЬНЫЕ ИНСТРУКЦИИ:
Обрати особое внимание на обсуждение бюджета 
и выдели все цифры в отдельный раздел"
</code></pre><h2>4.8 Мультиязычность</h2><h3>4.8.1 Текущая поддержка</h3><p><strong>Основной язык:</strong> Русский</p><p><strong>Возможность расширения:</strong>
<ul><li>Промпты структурированы для лёгкой локализации</li>
<li>Claude 3.7 поддерживает множество языков</li>
<li>Требуется только перевод системных промптов</li>
</ul>
<h3>4.8.2 Пример мультиязычного промпта</h3><pre><code class="language-">LANGUAGE DETECTION:
Определи язык транскрибации автоматически.
Создай сводку на том же языке, что и транскрибация.</p><p>Если транскрибация на русском → сводка на русском
Если транскрибация на английском → сводка на английском
И так далее для других языков.
</code></pre>`
    },
    'mini-app': {
        title: 'Мини-приложение',
        content: `<h1>5. Telegram Mini App (Мини-приложение)</h1><h2>5.1 Обзор мини-приложения</h2><p>EventSummaryBot включает полнофункциональное Telegram Mini App для управления балансом минут и отслеживания статистики использования. Мини-приложение представляет собой веб-приложение, встроенное в Telegram, которое предоставляет удобный интерфейс для:</p><ul><li>Просмотра баланса минут транскрибации</li>
<li>Покупки дополнительных минут</li>
<li>Отслеживания истории использования</li>
<li>Просмотра новостей и обновлений</li>
</ul>
<h3>5.1.1 Архитектура мини-приложения</h3><pre><code class="language-">┌─────────────────────────────────────────────────┐
│        TELEGRAM CLIENT (iOS/Android/Web)        │
│    ┌─────────────────────────────────────┐     │
│    │     Telegram Mini App WebView       │     │
│    │                                     │     │
│    │  ┌───────────────────────────────┐ │     │
│    │  │   Frontend (HTML/CSS/JS)      │ │     │
│    │  │   - index.html                │ │     │
│    │  │   - app.js                    │ │     │
│    │  │   - style.css                 │ │     │
│    │  └───────────┬───────────────────┘ │     │
│    └──────────────┼─────────────────────┘     │
└───────────────────┼─────────────────────────────┘
                    │ HTTPS
                    ▼
      ┌─────────────────────────────┐
      │   Flask Backend (REST API)  │
      │   - main.py                 │
      │   - controllers/            │
      │   - services/               │
      │   - models/                 │
      └──────┬──────────────────────┘
             │
             ├──────────► Google Sheets (БД)
             ├──────────► YooKassa (Платежи)
             └──────────► Telegram Bot API
</code></pre><h2>5.2 Frontend (Клиентская часть)</h2><h3>5.2.1 Технологический стек</h3><ul><li><strong>HTML5</strong> — структура страниц</li>
<li><strong>CSS3</strong> — стилизация с поддержкой темной/светлой темы</li>
<li><strong>Vanilla JavaScript</strong> — клиентская логика без фреймворков</li>
<li><strong>Telegram Web App API</strong> — интеграция с Telegram</li>
</ul>
<h3>5.2.2 Структура интерфейса</h3><h4>Экран авторизации (index.html)</h4><p><strong>Компоненты:</strong>
<pre><code class="language-html">&lt;div class="screen--login"&gt;
  &lt;form id="loginForm"&gt;
    &lt;input type="text" id="chatIdInput" placeholder="Chat ID"&gt;
    &lt;button type="submit"&gt;Войти&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
</code></pre><p><strong>Функциональность:</strong>
<ul><li>Автоматическое заполнение Chat ID из Telegram WebApp</li>
<li>Валидация формата Chat ID</li>
<li>Обработка ошибок авторизации</li>
<li>Переход к dashboard при успешном входе</li>
</ul>
<h4>Dashboard (главный экран)</h4><p><strong>Блоки интерфейса:</strong></p><p><li><strong>User Info Card</strong> — информация о пользователе</li>
<pre><code class="language-html">&lt;div class="user-info card"&gt;
  &lt;div class="user-info__avatar"&gt;...&lt;/div&gt;
  &lt;h3 id="userName"&gt;Пользователь&lt;/h3&gt;
  &lt;p id="userChatId"&gt;Chat ID: 123456789&lt;/p&gt;
  &lt;button id="logoutBtn"&gt;Выйти&lt;/button&gt;
&lt;/div&gt;
</code></pre><p><li><strong>Statistics Cards</strong> — статистика минут</li>
<pre><code class="language-html">&lt;div class="stats"&gt;
  &lt;div class="stats__card"&gt;
    &lt;div class="stat__value" id="totalMinutes"&gt;500&lt;/div&gt;
    &lt;div class="stat__label"&gt;Всего минут&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="stats__card"&gt;
    &lt;div class="stat__value" id="usedMinutes"&gt;120&lt;/div&gt;
    &lt;div class="stat__label"&gt;Использовано&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="stats__card"&gt;
    &lt;div class="stat__value" id="leftMinutes"&gt;380&lt;/div&gt;
    &lt;div class="stat__label"&gt;Осталось&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p><li><strong>Progress Bar</strong> — визуализация использования</li>
<pre><code class="language-html">&lt;div class="progress-card"&gt;
  &lt;div class="progress-info"&gt;
    &lt;h4&gt;Использование минут&lt;/h4&gt;
    &lt;span id="usagePercentage"&gt;24%&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="progress-bar"&gt;
    &lt;div class="progress-bar__fill" style="width: 24%"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p><li><strong>Tariffs</strong> — тарифные планы</li>
<pre><code class="language-html">&lt;div class="tariffs"&gt;
  &lt;button class="tariff" data-minutes="100" data-price="299"&gt;
    &lt;div class="tariff__minutes"&gt;100 минут&lt;/div&gt;
    &lt;div class="tariff__price"&gt;299 ₽&lt;/div&gt;
  &lt;/button&gt;
  
  &lt;button class="tariff tariff--popular" data-minutes="200" data-price="549"&gt;
    &lt;div class="tariff__badge"&gt;Популярный&lt;/div&gt;
    &lt;div class="tariff__minutes"&gt;200 минут&lt;/div&gt;
    &lt;div class="tariff__price"&gt;549 ₽&lt;/div&gt;
  &lt;/button&gt;
  
  &lt;button class="tariff" data-minutes="500" data-price="1299"&gt;
    &lt;div class="tariff__minutes"&gt;500 минут&lt;/div&gt;
    &lt;div class="tariff__price"&gt;1299 ₽&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
</code></pre><p><li><strong>News Section</strong> — лента новостей</li>
<pre><code class="language-html">&lt;div class="news-section"&gt;
  &lt;h4&gt;Новости&lt;/h4&gt;
  &lt;div class="news-list" id="newsList"&gt;
    &lt;!-- Динамически загружаемые новости --&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><h3>5.2.3 Клиентская логика (app.js)</h3><h4>Инициализация приложения</h4><pre><code class="language-javascript">// Инициализация Telegram WebApp
const tg = window.Telegram.WebApp;
tg.ready();
tg.expand();</p><p>// Установка темы в соответствии с Telegram
const colorScheme = tg.colorScheme;
document.documentElement.setAttribute('data-theme', colorScheme);</p><p>// Автозаполнение Chat ID
const initData = tg.initDataUnsafe;
if (initData.user) {
  document.getElementById('chatIdInput').value = initData.user.id;
  autoLogin(initData.user.id);
}
</code></pre><h4>Управление состоянием</h4><pre><code class="language-javascript">// Хранение данных пользователя
let currentUser = null;</p><p>// Авторизация
async function login(chatId) {
  try {
    const response = await fetch(<code>\${API_BASE}/api/users/login</code>, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chatid: chatId })
    });
    
    const data = await response.json();
    
    if (data.success) {
      currentUser = data.data;
      localStorage.setItem('chatid', chatId);
      showDashboard();
      loadUserData();
    } else {
      showError(data.error);
    }
  } catch (error) {
    showError('Ошибка подключения к серверу');
  }
}</p><p>// Загрузка данных пользователя
async function loadUserData() {
  const chatId = localStorage.getItem('chatid');
  
  try {
    const response = await fetch(<code>\${API_BASE}/api/users/\${chatId}</code>);
    const data = await response.json();
    
    if (data.success) {
      updateUI(data.data);
    }
  } catch (error) {
    console.error('Error loading user data:', error);
  }
}</p><p>// Обновление интерфейса
function updateUI(userData) {
  document.getElementById('userName').textContent = userData.username;
  document.getElementById('userChatId').textContent = <code>Chat ID: \${userData.chatid}</code>;
  document.getElementById('totalMinutes').textContent = userData.minutes_total;
  document.getElementById('usedMinutes').textContent = userData.minutes_used;
  document.getElementById('leftMinutes').textContent = userData.minutes_left;
  
  const percentage = (userData.minutes_used / userData.minutes_total * 100).toFixed(1);
  document.getElementById('usagePercentage').textContent = <code>\${percentage}%</code>;
  document.getElementById('progressFill').style.width = <code>\${percentage}%</code>;
}
</code></pre><h4>Обработка покупки</h4><pre><code class="language-javascript">// Обработчик клика на тариф
document.querySelectorAll('.tariff').forEach(button =&gt; {
  button.addEventListener('click', async function() {
    const minutes = this.dataset.minutes;
    const price = this.dataset.price;
    
    await purchaseMinutes(minutes, price);
  });
});</p><p>// Создание платежа
async function purchaseMinutes(minutes, price) {
  const chatId = localStorage.getItem('chatid');
  
  try {
    showLoader('Создание платежа...');
    
    const response = await fetch(<code>\${API_BASE}/api/payments/create</code>, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chatid: chatId,
        username: currentUser.username,
        minutes: parseInt(minutes),
        price: parseFloat(price)
      })
    });
    
    const data = await response.json();
    
    hideLoader();
    
    if (data.success) {
      // Открываем страницу оплаты YooKassa
      window.open(data.payment_url, '_blank');
      
      // Отслеживаем статус платежа
      trackPaymentStatus(data.payment_id);
    } else {
      showError(data.error);
    }
  } catch (error) {
    hideLoader();
    showError('Ошибка создания платежа');
  }
}</p><p>// Отслеживание статуса платежа
async function trackPaymentStatus(paymentId) {
  const checkInterval = setInterval(async () =&gt; {
    try {
      const response = await fetch(<code>\${API_BASE}/api/payments/\${paymentId}/status</code>);
      const data = await response.json();
      
      if (data.success &amp;&amp; data.status === 'succeeded') {
        clearInterval(checkInterval);
        showSuccess('Платёж успешно завершён!');
        loadUserData(); // Обновляем баланс
      } else if (data.status === 'failed' || data.status === 'canceled') {
        clearInterval(checkInterval);
        showError('Платёж не выполнен');
      }
    } catch (error) {
      console.error('Error checking payment status:', error);
    }
  }, 3000); // Проверка каждые 3 секунды
  
  // Останавливаем проверку через 5 минут
  setTimeout(() =&gt; clearInterval(checkInterval), 300000);
}
</code></pre><h4>Загрузка новостей</h4><pre><code class="language-javascript">async function loadNews() {
  try {
    const response = await fetch(<code>\${API_BASE}/api/news/latest?limit=5</code>);
    const data = await response.json();
    
    if (data.success) {
      displayNews(data.data.news);
    }
  } catch (error) {
    console.error('Error loading news:', error);
  }
}</p><p>function displayNews(newsItems) {
  const newsList = document.getElementById('newsList');
  newsList.innerHTML = '';
  
  if (newsItems.length === 0) {
    newsList.innerHTML = '&lt;p class="news-empty"&gt;Новостей пока нет&lt;/p&gt;';
    return;
  }
  
  newsItems.forEach(item =&gt; {
    const newsCard = document.createElement('div');
    newsCard.className = 'news-item';
    newsCard.innerHTML = <code>
      &lt;div class="news-item__date"&gt;\${formatDate(item.created_at)}&lt;/div&gt;
      &lt;h5 class="news-item__title"&gt;\${item.title}&lt;/h5&gt;
      &lt;p class="news-item__content"&gt;\${item.content}&lt;/p&gt;
      \${item.image_url ? </code>&lt;img src="\${item.image_url}" alt=""&gt;<code> : ''}
    </code>;
    newsList.appendChild(newsCard);
  });
}
</code></pre><h3>5.2.4 Стилизация (style.css)</h3><h4>CSS-переменные для тем</h4><pre><code class="language-css">:root {
  /* Светлая тема */
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --text-primary: #000000;
  --text-secondary: #666666;
  --accent: #0088cc;
  --border: #e0e0e0;
  --shadow: rgba(0, 0, 0, 0.1);
}</p><p>[data-theme="dark"] {
  /* Темная тема */
  --bg-primary: #1a1a1a;
  --bg-secondary: #2c2c2c;
  --text-primary: #ffffff;
  --text-secondary: #a0a0a0;
  --accent: #0088cc;
  --border: #3c3c3c;
  --shadow: rgba(0, 0, 0, 0.3);
}
</code></pre><h4>Адаптивный дизайн</h4><pre><code class="language-css">/* Мобильные устройства */
@media (max-width: 768px) {
  .stats {
    grid-template-columns: 1fr;
  }
  
  .tariffs {
    flex-direction: column;
  }
  
  .tariff {
    width: 100%;
  }
}</p><p>/* Планшеты */
@media (min-width: 769px) and (max-width: 1024px) {
  .stats {
    grid-template-columns: repeat(2, 1fr);
  }
}</p><p>/* Десктоп */
@media (min-width: 1025px) {
  .stats {
    grid-template-columns: repeat(3, 1fr);
  }
}
</code></pre><h2>5.3 Backend (Flask API)</h2><h3>5.3.1 Структура приложения</h3><pre><code class="language-">main.py                    # Точка входа, настройка Flask
wsgi.py                    # WSGI сервер для production
requirements.txt           # Python зависимости</p><p>app/
├── config/
│   └── google_sheets.py   # Подключение к Google Sheets
│
├── controllers/           # Обработчики запросов
│   ├── user_controller.py
│   ├── payment_controller.py
│   ├── news_controller.py
│   └── admin_controller.py
│
├── services/              # Бизнес-логика
│   ├── user_service.py
│   ├── payment_service.py
│   ├── payment_history_service.py
│   └── news_service.py
│
├── models/                # Модели данных
│   ├── payment.py
│   └── news.py
│
├── routes/                # API маршруты
│   ├── users.py
│   ├── payments.py
│   ├── news.py
│   └── admin.py
│
├── middleware/            # Промежуточные обработчики
│   ├── auth_middleware.py
│   └── error_handler.py
│
└── utils/                 # Утилиты
    ├── logger.py
    └── validation.py
</code></pre><h3>5.3.2 Ключевые эндпоинты API</h3><h4>Пользователи</h4><p><strong>POST /api/users/login</strong>
<pre><code class="language-python">def login():
    """Авторизация пользователя по Chat ID"""
    data = request.get_json()
    chat_id = data.get('chatid')
    
    user = user_service.get_user_by_chat_id(chat_id)
    
    if user:
        return jsonify({
            'success': True,
            'data': user
        }), 200
    else:
        return jsonify({
            'success': False,
            'error': 'Пользователь не найден'
        }), 404
</code></pre><p><strong>GET /api/users/:chatid</strong>
<pre><code class="language-python">def get_user_data(chatid):
    """Получение данных пользователя"""
    try:
        user = user_service.get_user_by_chat_id(chatid)
        
        return jsonify({
            'success': True,
            'data': user
        }), 200
    except Exception as error:
        return jsonify({
            'success': False,
            'error': str(error)
        }), 500
</code></pre><h4>Платежи</h4><p><strong>POST /api/payments/create</strong>
<pre><code class="language-python">def create_payment():
    """Создание платежа через YooKassa"""
    data = request.get_json()
    minutes = data.get('minutes')
    price = data.get('price')
    chat_id = data.get('chatid')
    username = data.get('username', 'user')
    
    payment = payment_service.create_payment(minutes, price, chat_id, username)
    
    return jsonify({
        'success': True,
        'payment_url': payment['payment_url'],
        'payment_id': payment['payment_id']
    }), 200
</code></pre><p><strong>POST /api/payments/webhook</strong>
<pre><code class="language-python">def webhook():
    """Webhook от YooKassa о статусе платежа"""
    data = request.get_json()
    
    # Проверка подписи (важно для безопасности)
    # signature_verification...
    
    payment_service.handle_webhook(data)
    
    return jsonify({'success': True}), 200
</code></pre><p><strong>GET /api/payments/:paymentId/status</strong>
<pre><code class="language-python">def get_payment_status(payment_id):
    """Получение статуса платежа"""
    status = payment_service.get_payment_status(payment_id)
    
    return jsonify({
        'success': True,
        'status': status
    }), 200
</code></pre><h3>5.3.3 Сервисы</h3><h4>UserService</h4><pre><code class="language-python">class UserService:
    def get_user_by_chat_id(self, chat_id):
        """Получить пользователя из Google Sheets"""
        rows = google_sheets_config.get_all_records_fixed()
        
        for row in rows:
            if str(row.get('chatid')) == str(chat_id):
                return {
                    'chatid': row.get('chatid'),
                    'username': row.get('username'),
                    'minutes_total': self._parse_number(row.get('minutes_total', 0)),
                    'minutes_used': self._parse_number(row.get('minutes_used', 0)),
                    'minutes_left': self._parse_number(row.get('minutes_left', 0))
                }
        
        return None
    
    def update_user_minutes(self, chat_id, additional_minutes):
        """Добавить минуты пользователю"""
        sheet = google_sheets_config.get_sheet()
        rows = google_sheets_config.get_all_records_fixed()
        
        # Находим пользователя
        user_row_index = None
        for idx, row in enumerate(rows, start=2):
            if str(row.get('chatid')) == str(chat_id):
                user_row_index = idx
                break
        
        if user_row_index is None:
            raise Exception('Пользователь не найден')
        
        # Обновляем minutes_total и minutes_left
        current_total = self._parse_number(rows[user_row_index - 2].get('minutes_total', 0))
        current_left = self._parse_number(rows[user_row_index - 2].get('minutes_left', 0))
        
        new_total = current_total + additional_minutes
        new_left = current_left + additional_minutes
        
        sheet.update_cell(user_row_index, 3, new_total)  # minutes_total
        sheet.update_cell(user_row_index, 5, new_left)   # minutes_left
        
        return {
            'chatid': chat_id,
            'minutes_total': new_total,
            'minutes_left': new_left
        }
</code></pre><h4>PaymentService</h4><pre><code class="language-python">class PaymentService:
    def create_payment(self, minutes, price, chat_id, username):
        """Создать платёж в YooKassa"""
        payment_id = str(uuid.uuid4())
        
        # Создание платежа в YooKassa
        yookassa_payment = {
            'amount': {
                'value': str(price),
                'currency': 'RUB'
            },
            'confirmation': {
                'type': 'redirect',
                'return_url': RETURN_URL
            },
            'capture': True,
            'description': f'Покупка {minutes} минут',
            'metadata': {
                'chatid': chat_id,
                'minutes': minutes,
                'payment_id': payment_id
            }
        }
        
        response = requests.post(
            'https://api.yookassa.ru/v3/payments',
            auth=(SHOP_ID, SECRET_KEY),
            headers={'Content-Type': 'application/json'},
            json=yookassa_payment
        )
        
        yookassa_data = response.json()
        
        # Сохраняем платёж в Google Sheets
        payment_history_service.create_payment({
            'payment_id': payment_id,
            'chatid': chat_id,
            'username': username,
            'minutes': minutes,
            'price': price,
            'status': 'pending',
            'yookassa_payment_id': yookassa_data['id']
        })
        
        return {
            'payment_id': payment_id,
            'payment_url': yookassa_data['confirmation']['confirmation_url']
        }
    
    def handle_webhook(self, data):
        """Обработка webhook от YooKassa"""
        event = data.get('event')
        payment_data = data.get('object')
        
        if event == 'payment.succeeded':
            metadata = payment_data.get('metadata', {})
            chatid = metadata.get('chatid')
            minutes = int(metadata.get('minutes', 0))
            payment_id = metadata.get('payment_id')
            
            # Обновляем статус платежа
            payment_history_service.update_payment_status(payment_id, 'succeeded')
            
            # Добавляем минуты пользователю
            user_service.update_user_minutes(chatid, minutes)
            
            # Отправляем уведомление в Telegram
            send_telegram_notification(chatid, f'✅ Платёж успешно завершён! Добавлено {minutes} минут.')
        
        elif event == 'payment.canceled':
            payment_id = payment_data.get('metadata', {}).get('payment_id')
            payment_history_service.update_payment_status(payment_id, 'canceled')
</code></pre><h2>5.4 Интеграция с YooKassa</h2><h3>5.4.1 Настройка</h3><p><strong>Необходимые данные:</strong>
<ul><li><code>YOOKASSA_SHOP_ID</code> — ID магазина</li>
<li><code>YOOKASSA_SECRET_KEY</code> — секретный ключ</li>
<li><code>RETURN_URL</code> — URL возврата после оплаты</li>
</ul>
<strong>Конфигурация в .env:</strong>
<pre><code class="language-">YOOKASSA_SHOP_ID=your_shop_id
YOOKASSA_SECRET_KEY=your_secret_key
YOOKASSA_RETURN_URL=https://t.me/EventSummaryBot
</code></pre><h3>5.4.2 Тарифы</h3><table>
<thead><tr><th>Тариф</th><th>Минуты</th><th>Цена</th><th>Цена за минуту</th><th>Популярность</th></tr></thead>
<tbody>
<tr><td>Базовый</td><td>100</td><td>299₽</td><td>2.99₽</td><td>Средняя</td></tr>
<tr><td>Популярный</td><td>200</td><td>549₽</td><td>2.75₽</td><td><strong>Высокая</strong></td></tr>
<tr><td>Премиум</td><td>500</td><td>1299₽</td><td>2.60₽</td><td>Средняя</td></tr>
</tbody></table><h2>5.5 Администрирование</h2><h3>5.5.1 Админ-панель (admin.html)</h3><p><strong>Функциональность:</strong>
<ul><li>Просмотр всех пользователей</li>
<li>Поиск по Chat ID или username</li>
<li>Статистика по платежам</li>
<li>Управление новостями</li>
<li>Топ пользователей по использованию</li>
</ul>
<strong>Доступ:</strong>
<ul><li>URL: <code>/admin.html</code></li>
<li>Авторизация: <code>/admin-login.html</code></li>
<li>Защита: bcrypt хеширование паролей</li>
</ul>
<h3>5.5.2 Управление новостями</h3><p><strong>Создание новости:</strong>
<pre><code class="language-javascript">async function createNews(newsData) {
  const response = await fetch(<code>\${API_BASE}/api/news</code>, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': <code>Bearer \${adminToken}</code>
    },
    body: JSON.stringify(newsData)
  });
  
  return await response.json();
}
</code></pre><p><strong>Редактирование:</strong>
<pre><code class="language-javascript">async function updateNews(newsId, newsData) {
  const response = await fetch(<code>\${API_BASE}/api/news/\${newsId}</code>, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': <code>Bearer \${adminToken}</code>
    },
    body: JSON.stringify(newsData)
  });
  
  return await response.json();
}
</code></pre><h2>5.6 Возможности и преимущества</h2><h3>5.6.1 Для пользователей</h3><p>✅ <strong>Удобство:</strong>
<ul><li>Встроено в Telegram, не требует установки</li>
<li>Быстрый доступ к балансу</li>
<li>Простая покупка минут</li>
</ul>
✅ <strong>Прозрачность:</strong>
<ul><li>Видна вся история использования</li>
<li>Понятные тарифы</li>
<li>Отслеживание каждой транзакции</li>
</ul>
✅ <strong>Безопасность:</strong>
<ul><li>Оплата через YooKassa</li>
<li>Защищённое соединение (HTTPS)</li>
<li>Конфиденциальность данных</li>
</ul>
<h3>5.6.2 Для бизнеса</h3><p>✅ <strong>Монетизация:</strong>
<ul><li>Прямая покупка минут</li>
<li>Различные тарифы</li>
<li>Автоматическая обработка платежей</li>
</ul>
✅ <strong>Аналитика:</strong>
<ul><li>Статистика использования</li>
<li>Конверсия покупок</li>
<li>Популярность тарифов</li>
</ul>
✅ <strong>Масштабируемость:</strong>
<ul><li>Готов к росту числа пользователей</li>
<li>Простое добавление новых тарифов</li>
<li>Гибкая ценовая политика</li>
</ul>`
    },
    'use-cases': {
        title: 'Примеры использования',
        content: `<h1>6. Рабочие сценарии и примеры использования</h1><h2>6.1 Сценарий 1: Автоматическая обработка Zoom конференции</h2><h3>6.1.1 Описание</h3><p>Пользователь проводит еженедельную встречу команды через Zoom. После завершения конференции система автоматически создаёт транскрибацию и предлагает сгенерировать сводку.</p><h3>6.1.2 Участники</h3><ul><li><strong>Организатор встречи</strong> — руководитель проекта</li>
<li><strong>Zoom</strong> — платформа для видеоконференций</li>
<li><strong>EventSummaryBot</strong> — система обработки</li>
<li><strong>Ответственные лица</strong> — получатели уведомлений</li>
</ul>
<h3>6.1.3 Предусловия</h3><p><li>Zoom интеграция настроена (webhook подписка активна)</li>
<li>Организатор имеет активную подписку Zoom с функцией записи</li>
<li>В Google Sheets указаны Chat ID ответственных лиц</li>
<li>У пользователей достаточно минут на балансе</li></p><h3>6.1.4 Пошаговый процесс</h3><pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Завершение конференции Zoom                             │
└─────────────────────────────────────────────────────────────────┘</p><p>Действие: Организатор завершает встречу
Zoom: Начинает обработку записи (обычно 5-10 минут)
       ↓
Zoom: Генерирует событие "recording.completed"
       ↓
Zoom: Отправляет webhook на n8n endpoint</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Получение записи                                        │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n (Zoom_main workflow):
  1. Webhook получает событие
  2. Извлекает meeting_id из payload
  3. Формирует URL для получения метаданных
  4. Запрашивает информацию о записи через Zoom API
  5. Получает download_url аудиофайла</p><p>Результат: URL для скачивания MP3 записи</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Скачивание и транскрибация                              │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n:
  1. Скачивает MP3 файл по download_url
  2. Проверяет размер файла (не пустой)
  3. Подготавливает метаданные для Whisper:
     - Имя файла: voice.mp3
     - Модель: large-v2
     - Параметры: upgrade_transcribation=false
  4. Вызывает подчиненный Whisper workflow
  5. Ожидает результата транскрибации</p><p>Whisper workflow:
  1. Получает аудиофайл
  2. Отправляет на Whisper API
  3. Получает текстовую транскрибацию
  4. Возвращает результат</p><p>Длительность: ~1/10 длительности записи
Пример: 60 мин запись = ~6 мин транскрибация</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Сохранение транскрибации                                │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n:
  1. Создаёт новый Google Doc в папке "Полная транскрибация"
  2. Название документа: "[Meeting ID] - [Дата и время]"
  3. Вставляет полную транскрибацию в документ
  4. Сохраняет изменения
  5. Получает ссылку на документ</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Расчет метаданных                                       │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n (JavaScript Code nodes):
  1. Извлекает recording_start и recording_end
  2. Вычисляет длительность конференции
  3. Форматирует даты в читабельный вид
     Пример: "24-10-2025 с 10:00 до 11:30"
  4. Формирует строку длительности
     Пример: "01:30:45"</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Рассылка уведомлений                                    │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n:
  1. Запрашивает список ответственных лиц из Google Sheets
     Фильтр: chatid in [665747123, 418926871]
  2. Для каждого получателя:
     - Формирует персональное сообщение
     - Добавляет inline-кнопки:
       ✅ "Да" (callback_data: "yes")
       ❌ "Нет" (callback_data: "no")
       🎙️ "Ссылка на транскрибацию" (url)
       📝 "Дополнить сводку" (callback_data: "addfile")
     - Отправляет через Telegram Bot API</p><p>Сообщение:
"""
🔔 Появилась новая запись в облаке Zoom</p><p>Хотите создать сводку?</p><p>📅 Дата конференции: 24-10-2025 (С 10:00 до 11:30)
⌛️ Длительность: 01:30:45</p><p>Вы можете дополнить сводку. Просто нажмите снизу кнопку "Дополнить сводку 📝"
"""</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 7: Пользователь выбирает действие                          │
└─────────────────────────────────────────────────────────────────┘</p><p>Варианты:
  A) Нажимает "Да" → переход к генерации сводки (Сценарий 2)
  B) Нажимает "Нет" → workflow завершается
  C) Открывает транскрибацию → просмотр в Google Docs
  D) Нажимает "Дополнить сводку" → upload дополнительных файлов
</code></pre><h3>6.1.5 Результат</h3><p>✅ <strong>Созданы артефакты:</strong>
<ul><li>Google Doc с полной транскрибацией</li>
<li>Метаданные конференции (длительность, дата)</li>
<li>Уведомления отправлены ответственным лицам</li>
</ul>
✅ <strong>Списание минут:</strong>
<ul><li>Длительность записи: 90 минут</li>
<li>Списано с баланса каждого ответственного лица</li>
</ul>
<h3>6.1.6 Возможные проблемы и решения</h3><table>
<thead><tr><th>Проблема</th><th>Причина</th><th>Решение</th></tr></thead>
<tbody>
<tr><td>Webhook не получен</td><td>Неверная конфигурация Zoom</td><td>Проверить URL webhook в настройках Zoom</td></tr>
<tr><td>Файл не скачивается</td><td>Истёк токен доступа</td><td>Обновить OAuth токен Zoom</td></tr>
<tr><td>Транскрибация пустая</td><td>Тишина в записи</td><td>Проверить запись вручную</td></tr>
<tr><td>Недостаточно минут</td><td>Баланс исчерпан</td><td>Уведомить пользователя о необходимости пополнения</td></tr>
</tbody></table><p>---</p><h2>6.2 Сценарий 2: Генерация сводки с выбором типа</h2><h3>6.2.1 Описание</h3><p>Пользователь получил уведомление о готовности транскрибации и хочет создать сводку определённого типа (например, протокол собрания).</p><h3>6.2.2 Пошаговый процесс</h3><pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Подтверждение создания сводки                           │
└─────────────────────────────────────────────────────────────────┘</p><p>Пользователь: Нажимает кнопку "Да ✅" в сообщении от бота
       ↓
Telegram: Отправляет callback_query с data="yes"
       ↓
n8n: Получает callback и показывает выбор типа сводки</p><p>Сообщение:
"""
Выберите тип сводки:</p><p>📋 Гибридная сводка (рекомендуется для рабочих встреч)
📚 Конспект лекции (структурированный материал)
📊 Отчёт о встрече (деловой формат)
📝 Протокол собрания (официальный документ)
📖 Детальный конспект (с временными метками)
"""</p><p>Inline-кнопки:
<ul><li>"📋 Гибридная" → callback_data: "HybridAudio"</li>
<li>"📚 Лекция" → callback_data: "LectureAudio"</li>
<li>"📊 Отчёт" → callback_data: "ReportAudio"</li>
<li>"📝 Протокол" → callback_data: "MeetingAudio"</li>
<li>"📖 Детальный" → callback_data: "KonspektAudio"</li>
</ul>
┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Загрузка контекста                                      │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n (generation_svodka_audio workflow):
  1. Получает callback_data (например, "MeetingAudio")
  2. Switch node направляет в соответствующую ветку
  3. Параллельно загружает:
     a) Системный промпт для типа "Meeting" из Google Docs
     b) Транскрибацию из Google Docs (последняя созданная)
     c) RAG документы из Google Drive (контекстные материалы)</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Подготовка промпта                                      │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n (Merge node):
  Объединяет:
  - Системный промпт (инструкции для Claude)
  - Текст транскрибации
  - RAG контекст (если применимо)</p><p>Финальный промпт:
"""
System: [Инструкции по созданию протокола собрания]</p><p>User: [Полная транскрибация конференции]</p><p>Additional Context: [RAG документы с терминологией]
"""</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Генерация сводки через Claude                           │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n → Anthropic Claude 3.7 Sonnet:
  1. Отправляет подготовленный промпт
  2. Claude анализирует транскрибацию
  3. Структурирует информацию согласно формату
  4. Генерирует сводку
  5. Удаляет Markdown разметку
  6. Возвращает результат</p><p>Параметры:
<ul><li>Model: claude-3-7-sonnet-20250219</li>
<li>Temperature: 0.3 (для большей точности)</li>
<li>Max tokens: 8000</li>
</ul>
Длительность: ~30-60 секунд</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Сохранение сводки                                       │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n:
  1. Создаёт новый Google Doc
     Папка: "Сводки EventSummaryBot"
     Название: "[Тип] - [Meeting ID] - [Дата]"
     Пример: "Протокол - 987654321 - 24-10-2025"
  2. Вставляет сгенерированную сводку
  3. Сохраняет документ
  4. Получает публичную ссылку</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Отправка результата пользователю                        │
└─────────────────────────────────────────────────────────────────┘</p><p>n8n → Telegram Bot:
  Отправляет сообщение:
  """
  ✅ Сводка готова!
  
  Тип: Протокол собрания
  Дата конференции: 24-10-2025
  Длительность: 01:30:45
  
  📄 Открыть сводку
  🎙️ Полная транскрибация
  """
  
  Inline-кнопки:
  - "📄 Открыть сводку" → ссылка на Google Doc
  - "🎙️ Полная транскрибация" → ссылка на транскрибацию
  - "🔄 Создать другой тип сводки" → callback_data: "regenerate"
  - "❓ Задать вопрос по сводке" → callback_data: "askaudio"
</code></pre><h3>6.2.3 Результат</h3><p>✅ <strong>Получена сводка:</strong>
<ul><li>Формат: Протокол собрания</li>
<li>Длина: ~2000-3000 слов</li>
<li>Структура: Согласно промпту</li>
<li>Сохранена: Google Docs</li>
</ul>
✅ <strong>Доступ:</strong>
<ul><li>Ссылка отправлена в Telegram</li>
<li>Документ доступен для редактирования</li>
<li>Можно экспортировать в PDF/DOCX</li>
</ul>
---</p><h2>6.3 Сценарий 3: Интерактивное общение с транскрибацией</h2><h3>6.3.1 Описание</h3><p>Пользователь хочет уточнить информацию из транскрибации, не читая её целиком. Задаёт вопросы боту, который отвечает на основе содержимого.</p><h3>6.3.2 Пошаговый процесс</h3><pre><code class="language-">Пользователь: /askaudio Кто был ответственным за задачу по тестированию?
       ↓
EventSummaryBot (главный workflow):
  1. Распознаёт команду /askaudio
  2. Извлекает текст вопроса (после команды)
  3. Вызывает workflow "askaudio" (Execute Workflow node)
  4. Передаёт:
     - chatid пользователя
     - текст вопроса
       ↓
askaudio workflow:
  1. Загружает последнюю транскрибацию из Google Drive
  2. Сортирует файлы по дате создания
  3. Берет самый новый документ
  4. Извлекает содержимое через Google Docs API
       ↓
  5. Формирует промпт:
     System: Ты помощник, отвечающий согласно транскрибации
     Context: [Полная транскрибация]
     User: Кто был ответственным за задачу по тестированию?
       ↓
  6. Отправляет в Anthropic Claude (Agent node)
  7. Claude анализирует транскрибацию
  8. Находит релевантную информацию
  9. Формирует ответ
       ↓
Bot → User:
"""
Согласно транскрибации, ответственным за тестирование была 
назначена Мария Иванова. Это было решено в 45:23 при 
обсуждении распределения задач на следующий спринт.</p><p>Также упоминалось, что ей нужно будет согласовать план 
тестирования с командой разработки до пятницы.
"""
</code></pre><h3>6.3.3 Примеры вопросов и ответов</h3><p><strong>Пример 1: Поиск конкретной информации</strong>
<pre><code class="language-">Q: /askaudio Какой бюджет был утверждён для маркетинговой кампании?</p><p>A: В транскрибации был утверждён бюджет 500,000 рублей для 
маркетинговой кампании на Q4. Это было озвучено финансовым 
директором в начале встречи (08:15). Дополнительно обсуждалось, 
что 200,000 пойдёт на digital-рекламу, а оставшиеся 300,000 на 
офлайн-мероприятия.
</code></pre><p><strong>Пример 2: Запрос списка</strong>
<pre><code class="language-">Q: /askaudio Перечисли все принятые решения</p><p>A: На встрече были приняты следующие решения:</p><p><li>Запустить бета-тестирование 15 ноября (ответственный: Алексей)</li>
<li>Увеличить команду дизайнеров на 2 человека (HR приступит к поиску)</li>
<li>Провести презентацию для инвесторов до конца месяца (организует Елена)</li>
<li>Изменить архитектуру модуля аутентификации (тех.лид: Дмитрий)</li>
<li>Перенести следующую встречу на среду, 10:00</li>
</code></pre><p><strong>Пример 3: Уточняющий вопрос</strong>
<pre><code class="language-">Q: /askaudio Что конкретно говорилось про интеграцию с CRM?</p><p>A: По поводу интеграции с CRM обсуждались следующие моменты:</p><p>• Текущий статус: завершена интеграция с Битрикс24, осталась Salesforce
• Проблема: нестандартные поля в Salesforce требуют дополнительной доработки
• Решение: привлечь внешнего консультанта по Salesforce API
• Сроки: планируется завершить до конца квартала
• Бюджет: выделено 150,000 рублей на консультанта</p><p>Это обсуждение происходило примерно в середине встречи, когда 
говорили про техническую часть проекта.
</code></pre><p>---</p><h2>6.4 Сценарий 4: Покупка минут через мини-приложение</h2><h3>6.4.1 Описание</h3><p>Пользователь израсходовал все минуты и хочет пополнить баланс для продолжения использования бота.</p><h3>6.4.2 Пошаговый процесс</h3><pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Открытие мини-приложения                                │
└─────────────────────────────────────────────────────────────────┘</p><p>Пользователь: Нажимает на кнопку "💳 Купить минуты" в боте
       ↓
Telegram: Открывает WebView с мини-приложением
       ↓
Mini App (index.html):
  1. Инициализирует Telegram WebApp API
  2. Получает Chat ID из Telegram
  3. Автоматически логинит пользователя
  4. Загружает данные через API</p><p>GET /api/users/123456789
Response:
{
  "success": true,
  "data": {
    "chatid": "123456789",
    "username": "john_doe",
    "minutes_total": 200,
    "minutes_used": 200,
    "minutes_left": 0  ← Баланс исчерпан
  }
}</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Просмотр статистики                                     │
└─────────────────────────────────────────────────────────────────┘</p><p>Mini App отображает:
┌─────────────────────────────────────────┐
│  EventSummaryBot                        │
│  ────────────────────────────────────── │
│  👤 john_doe                            │
│  Chat ID: 123456789             [Выйти] │
│  ────────────────────────────────────── │
│  📊 Всего минут:      200               │
│  ⏱️ Использовано:    200               │
│  ⚡ Осталось:         0 ⚠️              │
│  ────────────────────────────────────── │
│  Использование: ████████████ 100%      │
│  ────────────────────────────────────── │
│  💳 Пополнить минуты                    │
│  ┌─────────────────────────────────────┐│
│  │  100 минут        299 ₽            ││
│  └─────────────────────────────────────┘│
│  ┌─────────────────────────────────────┐│
│  │ [🔥 Популярный]                     ││
│  │  200 минут        549 ₽            ││
│  └─────────────────────────────────────┘│
│  ┌─────────────────────────────────────┐│
│  │  500 минут        1299 ₽           ││
│  └─────────────────────────────────────┘│
└─────────────────────────────────────────┘</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Выбор тарифа и создание платежа                         │
└─────────────────────────────────────────────────────────────────┘</p><p>Пользователь: Нажимает на "200 минут - 549 ₽"
       ↓
Mini App (app.js):
  1. Показывает loader "Создание платежа..."
  2. Отправляет запрос на backend</p><p>POST /api/payments/create
Body:
{
  "chatid": "123456789",
  "username": "john_doe",
  "minutes": 200,
  "price": 549
}
       ↓
Flask Backend (payment_controller.py):
  1. Валидирует данные
  2. Генерирует уникальный payment_id
  3. Создаёт платёж в YooKassa</p><p>POST https://api.yookassa.ru/v3/payments
Body:
{
  "amount": {
    "value": "549.00",
    "currency": "RUB"
  },
  "confirmation": {
    "type": "redirect",
    "return_url": "https://t.me/EventSummaryBot"
  },
  "capture": true,
  "description": "Покупка 200 минут",
  "metadata": {
    "chatid": "123456789",
    "minutes": "200",
    "payment_id": "pay_abc123xyz"
  }
}
       ↓
YooKassa Response:
{
  "id": "2b5f7c9d-8a3e-4f1b-9c6d-7e8a2b4c5d6f",
  "status": "pending",
  "paid": false,
  "confirmation": {
    "confirmation_url": "https://yookassa.ru/checkout/..."
  }
}
       ↓
Flask:
  1. Сохраняет платёж в Google Sheets:
     payment_id | chatid    | minutes | price | status
     pay_abc123 | 123456789 | 200     | 549   | pending
  
  2. Возвращает ответ Mini App</p><p>Response to Mini App:
{
  "success": true,
  "payment_url": "https://yookassa.ru/checkout/...",
  "payment_id": "pay_abc123xyz"
}</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Процесс оплаты                                          │
└─────────────────────────────────────────────────────────────────┘</p><p>Mini App:
  1. Открывает payment_url в новой вкладке
  2. Начинает опрос статуса платежа (каждые 3 секунды)</p><p>setInterval(() =&gt; {
  fetch('/api/payments/pay_abc123xyz/status')
}, 3000)
       ↓
Пользователь:
  1. Видит страницу YooKassa
  2. Выбирает способ оплаты (банковская карта)
  3. Вводит данные карты: XXXX XXXX XXXX 4444
  4. Вводит CVC: XXX
  5. Нажимает "Оплатить 549 ₽"
       ↓
YooKassa:
  1. Обрабатывает платёж через банк
  2. Получает подтверждение от банка
  3. Меняет статус платежа на "succeeded"
  4. Отправляет webhook на Flask</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Обработка успешного платежа                             │
└─────────────────────────────────────────────────────────────────┘</p><p>YooKassa → Flask Webhook:</p><p>POST /api/payments/webhook
Body:
{
  "type": "notification",
  "event": "payment.succeeded",
  "object": {
    "id": "2b5f7c9d-8a3e-4f1b-9c6d-7e8a2b4c5d6f",
    "status": "succeeded",
    "paid": true,
    "amount": {"value": "549.00"},
    "metadata": {
      "chatid": "123456789",
      "minutes": "200",
      "payment_id": "pay_abc123xyz"
    }
  }
}
       ↓
Flask (payment_service.py):
  1. Проверяет подпись webhook (безопасность)
  2. Извлекает metadata
  3. Обновляет статус платежа в Google Sheets:
     status: pending → succeeded
  4. Добавляет минуты пользователю в Google Sheets:
     minutes_total: 200 → 400
     minutes_left: 0 → 200
  5. Отправляет уведомление в Telegram</p><p>Telegram Bot → User:
"""
✅ Платёж успешно завершён!</p><p>Добавлено: 200 минут
Стоимость: 549 ₽</p><p>Ваш новый баланс: 200 минут</p><p>Спасибо за покупку! 🎉
"""</p><p>┌─────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Обновление интерфейса                                   │
└─────────────────────────────────────────────────────────────────┘</p><p>Mini App:
  1. Опрос статуса обнаруживает status="succeeded"
  2. Останавливает polling
  3. Показывает уведомление "Платёж успешно завершён!"
  4. Перезагружает данные пользователя</p><p>GET /api/users/123456789
Response:
{
  "chatid": "123456789",
  "username": "john_doe",
  "minutes_total": 400,
  "minutes_used": 200,
  "minutes_left": 200  ← Баланс пополнен!
}
       ↓
Mini App обновляет интерфейс:
│  📊 Всего минут:      400 (+200)        │
│  ⏱️ Использовано:    200               │
│  ⚡ Осталось:         200 ✅            │
│  ────────────────────────────────────── │
│  Использование: ██████░░░░░░ 50%       │
</code></pre><h3>6.4.3 Результат</h3><p>✅ <strong>Платёж проведён:</strong>
<ul><li>Сумма: 549₽</li>
<li>Добавлено минут: 200</li>
<li>Статус: succeeded</li>
</ul>
✅ <strong>Обновлён баланс:</strong>
<ul><li>Было: 0 минут</li>
<li>Стало: 200 минут</li>
<li>Можно продолжать использовать бот</li>
</ul>
---</p><h2>6.5 Сценарий 5: Административные задачи</h2><h3>6.5.1 Описание</h3><p>Администратор хочет проверить статистику использования, найти конкретного пользователя и опубликовать новость.</p><h3>6.5.2 Процесс</h3><pre><code class="language-">Администратор: Открывает /admin-login.html
       ↓
Вводит:
  Login: admin@example.com
  Password: ••••••••
       ↓
POST /api/auth/login
Body: {
  "email": "admin@example.com",
  "password": "SecurePassword123"
}
       ↓
Flask (admin_auth_service.py):
  1. Находит админа в Google Sheets
  2. Проверяет bcrypt hash пароля
  3. Генерирует JWT токен
  4. Возвращает токен</p><p>Response:
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "admin": {
    "email": "admin@example.com",
    "role": "super_admin"
  }
}
       ↓
Mini App сохраняет токен и показывает dashboard</p><p>═══════════════════════════════════════════════════════
ПРОСМОТР СТАТИСТИКИ
═══════════════════════════════════════════════════════</p><p>GET /api/admin/stats
Headers: Authorization: Bearer [JWT_TOKEN]</p><p>Response:
{
  "users": {
    "total": 1250,
    "active_this_month": 680,
    "new_this_month": 45
  },
  "payments": {
    "total_revenue": 1_245_000,
    "successful_payments": 890,
    "pending_payments": 12,
    "failed_payments": 23
  },
  "usage": {
    "total_minutes_sold": 156_000,
    "total_minutes_used": 98_420,
    "average_per_user": 145
  }
}</p><p>═══════════════════════════════════════════════════════
ПОИСК ПОЛЬЗОВАТЕЛЯ
═══════════════════════════════════════════════════════</p><p>Admin вводит в поиск: "john"</p><p>GET /api/admin/users/search?q=john
Headers: Authorization: Bearer [JWT_TOKEN]</p><p>Response:
{
  "success": true,
  "data": [
    {
      "chatid": "123456789",
      "username": "john_doe",
      "minutes_total": 400,
      "minutes_used": 200,
      "minutes_left": 200,
      "last_payment": "2025-10-24T14:00:00Z"
    },
    {
      "chatid": "987654321",
      "username": "johnny_smith",
      "minutes_total": 100,
      "minutes_used": 15,
      "minutes_left": 85,
      "last_payment": "2025-10-20T10:30:00Z"
    }
  ]
}</p><p>═══════════════════════════════════════════════════════
СОЗДАНИЕ НОВОСТИ
═══════════════════════════════════════════════════════</p><p>Admin заполняет форму:
  Заголовок: "Новая функция: экспорт в PDF"
  Содержание: "Теперь вы можете экспортировать сводки в PDF..."
  Изображение: [upload file]
  Приоритет: high</p><p>POST /api/news
Headers: Authorization: Bearer [JWT_TOKEN]
Body:
{
  "title": "Новая функция: экспорт в PDF",
  "content": "Теперь вы можете...",
  "image_url": "https://storage.com/news/image.jpg",
  "priority": "high",
  "is_published": true
}</p><p>Response:
{
  "success": true,
  "data": {
    "news_id": "news_042",
    "title": "Новая функция: экспорт в PDF",
    "created_at": "2025-10-24T15:30:00Z"
  }
}</p><p>Новость автоматически появляется в мини-приложении всех пользователей
</code></pre><p>---</p><h2>6.6 Метрики успеха</h2><h3>6.6.1 Ключевые показатели</h3><table>
<thead><tr><th>Метрика</th><th>Целевое значение</th><th>Текущее</th></tr></thead>
<tbody>
<tr><td>Время транскрибации (для 60 мин записи)</td><td>< 7 минут</td><td>6 минут</td></tr>
<tr><td>Время генерации сводки</td><td>< 60 секунд</td><td>45 секунд</td></tr>
<tr><td>Uptime системы</td><td>> 99.5%</td><td>99.7%</td></tr>
<tr><td>Точность транскрибации</td><td>> 90%</td><td>94%</td></tr>
<tr><td>Удовлетворённость качеством сводок</td><td>> 4.5/5</td><td>4.7/5</td></tr>
<tr><td>Конверсия в покупку (первый месяц)</td><td>> 15%</td><td>18%</td></tr>
<tr><td>Повторные покупки</td><td>> 60%</td><td>65%</td></tr>
</tbody></table>`
    },
    'error-handling': {
        title: 'Обработка ошибок',
        content: `<h1>7. Обработка ошибок и журналирование</h1><h2>7.1 Стратегия обработки ошибок</h2><h3>7.1.1 Уровни ошибок</h3><p>EventSummaryBot классифицирует ошибки по четырем уровням:</p><table>
<thead><tr><th>Уровень</th><th>Критичность</th><th>Действие</th><th>Уведомление пользователя</th></tr></thead>
<tbody>
<tr><td><strong>CRITICAL</strong></td><td>Система неработоспособна</td><td>Аварийная остановка, немедленное вмешательство</td><td>Сервис временно недоступен</td></tr>
<tr><td><strong>ERROR</strong></td><td>Отдельная функция не работает</td><td>Запись в лог, повтор операции</td><td>Ошибка выполнения операции</td></tr>
<tr><td><strong>WARNING</strong></td><td>Потенциальная проблема</td><td>Запись в лог, продолжение работы</td><td>(Обычно скрыто)</td></tr>
<tr><td><strong>INFO</strong></td><td>Информационное сообщение</td><td>Запись в лог</td><td>Нет</td></tr>
</tbody></table><h3>7.1.2 Принципы обработки</h3><p><li><strong>Fail Fast</strong> — быстрое обнаружение ошибок на раннем этапе</li>
<li><strong>Graceful Degradation</strong> — частичная работоспособность при сбоях</li>
<li><strong>User-Friendly Messages</strong> — понятные сообщения для пользователей</li>
<li><strong>Detailed Logging</strong> — подробные логи для разработчиков</li>
<li><strong>Automatic Retry</strong> — автоматический повтор для временных сбоев</li></p><h2>7.2 Типы ошибок и их обработка</h2><h3>7.2.1 Ошибки внешних API</h3><h4>Whisper API (Транскрибация)</h4><p><strong>Возможные ошибки:</strong>
<pre><code class="language-">1. HTTP 429 - Rate Limit Exceeded
<li>HTTP 500 - Internal Server Error</li>
<li>HTTP 413 - File Too Large</li>
<li>Timeout - Request Timeout</li>
<li>Network Error - Connection Failed</li>
</code></pre><p><strong>Обработка в n8n:</strong></p><pre><code class="language-javascript">// Node: Whisper Workflow
try {
  const transcription = await whisperAPI.transcribe(audioFile);
  return [{ json: { result: transcription } }];
} catch (error) {
  if (error.statusCode === 429) {
    // Rate limit - ждём и повторяем
    await new Promise(resolve =&gt; setTimeout(resolve, 5000));
    return await whisperAPI.transcribe(audioFile);
  } else if (error.statusCode === 413) {
    // Файл слишком большой - разбиваем на части
    throw new Error('Файл превышает максимальный размер. Разбейте запись на части до 4 часов.');
  } else if (error.statusCode &gt;= 500) {
    // Серверная ошибка - повторяем до 3 раз
    for (let i = 0; i &lt; 3; i++) {
      await new Promise(resolve =&gt; setTimeout(resolve, 10000 * (i + 1)));
      try {
        return await whisperAPI.transcribe(audioFile);
      } catch (retryError) {
        if (i === 2) throw retryError;
      }
    }
  } else {
    throw new Error(<code>Ошибка транскрибации: \${error.message}</code>);
  }
}
</code></pre><p><strong>Уведомление пользователя:</strong>
<pre><code class="language-">❌ Не удалось создать транскрибацию</p><p>Причина: Сервис транскрибации временно недоступен</p><p>Что делать:
• Попробуйте повторить через 5 минут
• Проверьте, что аудиофайл корректен
• Обратитесь в поддержку, если проблема сохраняется</p><p>ID ошибки: ERR_WHISPER_503_20251024143000
</code></pre><h4>Anthropic Claude API (Генерация сводок)</h4><p><strong>Возможные ошибки:</strong>
<pre><code class="language-">1. HTTP 429 - Rate Limit
<li>HTTP 400 - Invalid Request</li>
<li>HTTP 529 - Overloaded</li>
<li>Context Length Exceeded</li>
<li>Content Policy Violation</li>
</code></pre><p><strong>Обработка:</strong></p><pre><code class="language-javascript">// Node: ИИ для создания сводки
{
  "errorHandling": {
    "continueOnFail": true,
    "retryOnFail": true,
    "maxTries": 3,
    "retryInterval": 5000
  },
  "catchErrors": {
    "handler": "customErrorHandler",
    "actions": [
      {
        "condition": "statusCode === 429",
        "action": "exponentialBackoff",
        "maxWait": 60000
      },
      {
        "condition": "error.includes('context_length')",
        "action": "truncateInput",
        "maxTokens": 100000
      },
      {
        "condition": "statusCode === 529",
        "action": "waitAndRetry",
        "wait": 30000
      }
    ]
  }
}
</code></pre><p><strong>Fallback механизм:</strong></p><p>Если Claude недоступен, система:
<li>Сохраняет запрос в очередь</li>
<li>Уведомляет пользователя о задержке</li>
<li>Обрабатывает запросы из очереди при восстановлении сервиса</li></p><h4>Google APIs (Sheets, Docs, Drive)</h4><p><strong>Возможные ошибки:</strong>
<pre><code class="language-">1. 401 Unauthorized - Expired Token
<li>403 Forbidden - Insufficient Permissions</li>
<li>404 Not Found - Document Not Found</li>
<li>429 Rate Limit - Too Many Requests</li>
<li>500 Internal Server Error</li>
</code></pre><p><strong>Обработка:</strong></p><pre><code class="language-python"># app/config/google_sheets.py
class GoogleSheetsConfig:
    def get_sheet(self):
        try:
            if not self.is_authenticated or not self.doc:
                self.authenticate()
            return self.sheet
        except gspread.exceptions.APIError as e:
            if e.response.status_code == 401:
                # Token истёк - переавторизация
                logger.warning('Google token expired, re-authenticating')
                self.authenticate()
                return self.sheet
            elif e.response.status_code == 429:
                # Rate limit - exponential backoff
                logger.warning('Google API rate limit hit, waiting')
                time.sleep(5)
                return self.get_sheet()
            else:
                logger.error(f'Google Sheets API error: {e}')
                raise Exception('Ошибка подключения к базе данных')
</code></pre><h4>YooKassa API (Платежи)</h4><p><strong>Возможные ошибки:</strong>
<pre><code class="language-">1. Invalid Shop ID
<li>Invalid Secret Key</li>
<li>Payment Declined (банк отклонил)</li>
<li>3D Secure Failed</li>
<li>Insufficient Funds</li>
</code></pre><p><strong>Обработка:</strong></p><pre><code class="language-python"># app/services/payment_service.py
def create_payment(self, minutes, price, chat_id, username):
    try:
        response = requests.post(
            'https://api.yookassa.ru/v3/payments',
            auth=(SHOP_ID, SECRET_KEY),
            json=payment_data,
            timeout=10
        )
        
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.Timeout:
        logger.error('YooKassa timeout')
        raise Exception('Превышено время ожидания. Попробуйте позже.')
    
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            logger.critical('YooKassa authentication failed')
            raise Exception('Ошибка конфигурации платёжной системы')
        elif e.response.status_code == 400:
            error_data = e.response.json()
            logger.error(f'YooKassa validation error: {error_data}')
            raise Exception('Некорректные данные платежа')
        else:
            logger.error(f'YooKassa error: {e}')
            raise Exception('Ошибка создания платежа')
    
    except Exception as e:
        logger.error(f'Unexpected payment error: {e}')
        raise Exception('Непредвиденная ошибка при создании платежа')
</code></pre><h4>Zoom API</h4><p><strong>Возможные ошибки:</strong>
<pre><code class="language-">1. OAuth Token Expired
<li>Recording Not Found</li>
<li>Download URL Expired</li>
<li>Account Suspended</li>
</code></pre><p><strong>Обработка в n8n:</strong></p><pre><code class="language-javascript">// Node: Получает сведения о ласт записи
{
  "continueOnFail": true,
  "onError": "sendToUser",
  "errorMessage": "К сожалению, не удалось получить запись из Zoom. Возможно, запись ещё обрабатывается или была удалена."
}</p><p>// Retry Logic
if (error.statusCode === 404) {
  // Запись возможно ещё обрабатывается
  await new Promise(r =&gt; setTimeout(r, 60000)); // Ждём 1 минуту
  // Повторяем запрос
}
</code></pre><h3>7.2.2 Ошибки валидации данных</h3><h4>Flask API Validation</h4><p><strong>Пример валидации:</strong></p><pre><code class="language-python"># app/utils/validation.py
class ValidationError(Exception):
    def __init__(self, field, message):
        self.field = field
        self.message = message
        super().__init__(f'{field}: {message}')</p><p>def validate_chat_id(chat_id):
    if not chat_id:
        raise ValidationError('chatid', 'Chat ID обязателен')
    
    if not isinstance(chat_id, (str, int)):
        raise ValidationError('chatid', 'Chat ID должен быть строкой или числом')
    
    chat_id_str = str(chat_id)
    if not chat_id_str.isdigit():
        raise ValidationError('chatid', 'Chat ID должен содержать только цифры')
    
    if len(chat_id_str) &lt; 6 or len(chat_id_str) &gt; 12:
        raise ValidationError('chatid', 'Chat ID должен быть длиной от 6 до 12 символов')
    
    return chat_id_str</p><p>def validate_minutes(minutes):
    if not isinstance(minutes, int):
        try:
            minutes = int(minutes)
        except (ValueError, TypeError):
            raise ValidationError('minutes', 'Количество минут должно быть целым числом')
    
    if minutes &lt;= 0:
        raise ValidationError('minutes', 'Количество минут должно быть положительным')
    
    if minutes &gt; 10000:
        raise ValidationError('minutes', 'Максимальная покупка - 10000 минут')
    
    return minutes</p><p>def validate_price(price):
    if not isinstance(price, (int, float)):
        try:
            price = float(price)
        except (ValueError, TypeError):
            raise ValidationError('price', 'Цена должна быть числом')
    
    if price &lt;= 0:
        raise ValidationError('price', 'Цена должна быть положительной')
    
    if price &gt; 100000:
        raise ValidationError('price', 'Максимальная сумма платежа - 100000₽')
    
    return round(price, 2)
</code></pre><p><strong>Использование в контроллере:</strong></p><pre><code class="language-python"># app/controllers/payment_controller.py
def create_payment():
    try:
        data = request.get_json()
        
        # Валидация
        chat_id = validate_chat_id(data.get('chatid'))
        minutes = validate_minutes(data.get('minutes'))
        price = validate_price(data.get('price'))
        username = data.get('username', 'user')
        
        # Создание платежа
        payment = payment_service.create_payment(minutes, price, chat_id, username)
        
        return jsonify({
            'success': True,
            'payment_url': payment['payment_url'],
            'payment_id': payment['payment_id']
        }), 200
        
    except ValidationError as e:
        logger.warning(f'Validation error: {e}')
        return jsonify({
            'success': False,
            'error': e.message,
            'field': e.field
        }), 400
        
    except Exception as e:
        logger.error(f'Error creating payment: {e}')
        return jsonify({
            'success': False,
            'error': 'Ошибка создания платежа'
        }), 500
</code></pre><h3>7.2.3 Ошибки базы данных (Google Sheets)</h3><p><strong>Возможные проблемы:</strong>
<pre><code class="language-">1. User Not Found
<li>Concurrent Modifications</li>
<li>Data Type Mismatch</li>
<li>Sheet Structure Changed</li>
</code></pre><p><strong>Обработка:</strong></p><pre><code class="language-python"># app/services/user_service.py
def update_user_minutes(self, chat_id, additional_minutes):
    max_retries = 3
    retry_count = 0
    
    while retry_count &lt; max_retries:
        try:
            sheet = google_sheets_config.get_sheet()
            rows = google_sheets_config.get_all_records_fixed()
            
            # Находим пользователя
            user_row_index = None
            for idx, row in enumerate(rows, start=2):
                if str(row.get('chatid')) == str(chat_id):
                    user_row_index = idx
                    break
            
            if user_row_index is None:
                raise Exception('Пользователь не найден')
            
            # Получаем текущие значения
            current_total = self._parse_number(rows[user_row_index - 2].get('minutes_total', 0))
            current_left = self._parse_number(rows[user_row_index - 2].get('minutes_left', 0))
            
            # Обновляем
            new_total = current_total + additional_minutes
            new_left = current_left + additional_minutes
            
            # Атомарное обновление
            sheet.update_cell(user_row_index, 3, new_total)
            sheet.update_cell(user_row_index, 5, new_left)
            
            logger.info(f'Updated minutes for user {chat_id}: +{additional_minutes}')
            
            return {
                'chatid': chat_id,
                'minutes_total': new_total,
                'minutes_left': new_left
            }
            
        except gspread.exceptions.APIError as e:
            retry_count += 1
            if retry_count &gt;= max_retries:
                logger.error(f'Failed to update user minutes after {max_retries} retries')
                raise Exception('Ошибка обновления баланса. Попробуйте позже.')
            
            # Exponential backoff
            wait_time = 2 ** retry_count
            logger.warning(f'Retrying user update, attempt {retry_count}/{max_retries}')
            time.sleep(wait_time)
        
        except Exception as e:
            logger.error(f'Error updating user minutes: {e}')
            raise
</code></pre><h2>7.3 Журналирование (Logging)</h2><h3>7.3.1 Структура логов</h3><p><strong>Flask Backend:</strong></p><pre><code class="language-python"># app/utils/logger.py
import logging
import os
from datetime import datetime
from logging.handlers import RotatingFileHandler</p><p>def setup_logger():
    """Настройка логирования"""
    
    # Создание директории для логов
    log_dir = os.path.join(os.path.dirname(__file__), '../../logs')
    os.makedirs(log_dir, exist_ok=True)
    
    # Формат логов
    log_format = (
        '[%(asctime)s] %(levelname)-8s '
        '%(name)-15s '
        '%(funcName)-20s '
        'L%(lineno)-4d '
        '%(message)s'
    )
    
    formatter = logging.Formatter(log_format, datefmt='%Y-%m-%d %H:%M:%S')
    
    # Файл для всех логов
    all_logs_handler = RotatingFileHandler(
        os.path.join(log_dir, 'app.log'),
        maxBytes=10_000_000,  # 10 MB
        backupCount=5
    )
    all_logs_handler.setFormatter(formatter)
    all_logs_handler.setLevel(logging.DEBUG)
    
    # Файл только для ошибок
    error_logs_handler = RotatingFileHandler(
        os.path.join(log_dir, 'errors.log'),
        maxBytes=10_000_000,
        backupCount=5
    )
    error_logs_handler.setFormatter(formatter)
    error_logs_handler.setLevel(logging.ERROR)
    
    # Консольный вывод
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    
    # Настройка root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)
    root_logger.addHandler(all_logs_handler)
    root_logger.addHandler(error_logs_handler)
    root_logger.addHandler(console_handler)
    
    return root_logger
</code></pre><p><strong>Пример лога:</strong></p><pre><code class="language-">[2025-10-24 14:30:15] INFO     user_service    get_user_by_chat_id  L54   Fetching user 123456789
[2025-10-24 14:30:15] DEBUG    google_sheets   get_all_records      L113  Retrieved 1250 records
[2025-10-24 14:30:16] INFO     payment_service create_payment       L42   Creating payment for user 123456789: 200 minutes, 549₽
[2025-10-24 14:30:17] ERROR    payment_service create_payment       L68   YooKassa error: Connection timeout
[2025-10-24 14:30:17] INFO     payment_service create_payment       L72   Retrying payment creation (attempt 2/3)
[2025-10-24 14:30:19] INFO     payment_service create_payment       L78   Payment created successfully: pay_abc123xyz
</code></pre><h3>7.3.2 Уровни логирования</h3><p><strong>DEBUG:</strong>
<pre><code class="language-python">logger.debug('User data fetched from Google Sheets')
logger.debug(f'Transcription length: {len(transcription)} characters')
logger.debug(f'Payment metadata: {metadata}')
</code></pre><p><strong>INFO:</strong>
<pre><code class="language-python">logger.info(f'User {chat_id} logged in')
logger.info(f'Payment {payment_id} created')
logger.info(f'Transcription saved to Google Doc: {doc_url}')
</code></pre><p><strong>WARNING:</strong>
<pre><code class="language-python">logger.warning('Google API rate limit approaching')
logger.warning(f'User {chat_id} has low balance: {minutes_left} minutes')
logger.warning('Webhook signature verification skipped (dev mode)')
</code></pre><p><strong>ERROR:</strong>
<pre><code class="language-python">logger.error(f'Failed to transcribe audio: {error}')
logger.error(f'Payment webhook processing failed: {error}')
logger.error(f'User not found: {chat_id}')
</code></pre><p><strong>CRITICAL:</strong>
<pre><code class="language-python">logger.critical('Google Sheets authentication failed')
logger.critical('YooKassa credentials invalid')
logger.critical('Database connection lost')
</code></pre><h3>7.3.3 Логирование n8n workflows</h3><p><strong>Встроенное логирование n8n:</strong></p><ul><li>Все выполнения workflow сохраняются автоматически</li>
<li>Доступ через UI: Executions → История выполнений</li>
<li>Можно просмотреть данные каждого узла</li>
<li>Ошибки выделяются красным цветом</li>
</ul>
<strong>Дополнительное логирование через Code nodes:</strong></p><pre><code class="language-javascript">// Node: Custom Logger
const logEntry = {
  timestamp: new Date().toISOString(),
  workflow: 'Zoom_main',
  event: 'transcription_completed',
  meeting_id: $json.meeting_id,
  duration: $json.duration,
  status: 'success'
};</p><p>// Отправка в внешний сервис логирования (опционально)
await fetch('https://logs.example.com/api/log', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(logEntry)
});</p><p>// Логирование в консоль n8n
console.log('LOG:', logEntry);</p><p>return [{ json: logEntry }];
</code></pre><h3>7.3.4 Мониторинг и алерты</h3><p><strong>Критические события, требующие немедленного уведомления:</strong></p><p><li><strong>Сбой аутентификации Google</strong></li>
   <pre><code class="language-python">   if not google_sheets_config.authenticate():
       send_alert_to_admin('CRITICAL: Google Sheets auth failed')
   </code></pre><p><li><strong>Превышение rate limits</strong></li>
   <pre><code class="language-python">   if rate_limit_exceeded():
       send_alert_to_admin('WARNING: API rate limit exceeded')
   </code></pre><p><li><strong>Большое количество ошибок платежей</strong></li>
   <pre><code class="language-python">   if failed_payments_last_hour &gt; 10:
       send_alert_to_admin('ERROR: High payment failure rate')
   </code></pre><p><li><strong>Недоступность Whisper/Claude</strong></li>
   <pre><code class="language-python">   if whisper_downtime &gt; 300:  # 5 минут
       send_alert_to_admin('CRITICAL: Whisper API unavailable')
   </code></pre><p><strong>Каналы уведомлений:</strong>
<ul><li>Email администраторам</li>
<li>Telegram-канал для мониторинга</li>
<li>SMS для критических событий (опционально)</li>
</ul>
<h3>7.3.5 Ротация и архивирование логов</h3><p><strong>Политика хранения:</strong></p><table>
<thead><tr><th>Тип логов</th><th>Период хранения</th><th>Размер</th><th>Количество бэкапов</th></tr></thead>
<tbody>
<tr><td>app.log</td><td>30 дней</td><td>10 MB</td><td>5 файлов</td></tr>
<tr><td>errors.log</td><td>90 дней</td><td>10 MB</td><td>10 файлов</td></tr>
<tr><td>payments.log</td><td>365 дней</td><td>50 MB</td><td>12 файлов</td></tr>
<tr><td>audit.log</td><td>Бессрочно</td><td>100 MB</td><td>24 файла</td></tr>
</tbody></table><p><strong>Автоматическая очистка:</strong></p><pre><code class="language-python"># scripts/cleanup_logs.py
import os
import time
from datetime import datetime, timedelta</p><p>def cleanup_old_logs(log_dir, days_to_keep=30):
    """Удаление логов старше указанного периода"""
    cutoff_date = datetime.now() - timedelta(days=days_to_keep)
    
    for filename in os.listdir(log_dir):
        filepath = os.path.join(log_dir, filename)
        
        if not filename.endswith('.log') and not filename.endswith('.gz'):
            continue
        
        file_time = datetime.fromtimestamp(os.path.getmtime(filepath))
        
        if file_time &lt; cutoff_date:
            os.remove(filepath)
            print(f'Deleted old log: {filename}')</p><h1>Запускать через cron: 0 0 * * * python cleanup_logs.py</h1>
</code></pre><h2>7.4 Обработка ошибок в UI</h2><h3>7.4.1 Telegram Bot</h3><p><strong>Дружественные сообщения:</strong></p><pre><code class="language-">❌ Ошибка</p><p>Не удалось создать транскрибацию.
Причина: Файл слишком большой (максимум 50 MB)</p><p>Что делать:
• Сожмите аудиофайл
• Разбейте запись на части
• Используйте формат MP3 вместо WAV</p><p>Нужна помощь? /support
</code></pre><h3>7.4.2 Mini App</h3><p><strong>Toast уведомления:</strong></p><pre><code class="language-javascript">function showError(message) {
  const toast = document.getElementById('errorToast');
  const text = document.getElementById('errorToastText');
  text.textContent = message;
  toast.classList.add('show');
  
  setTimeout(() =&gt; {
    toast.classList.remove('show');
  }, 5000);
}</p><p>// Использование
try {
  await createPayment();
} catch (error) {
  showError('Не удалось создать платёж. Попробуйте позже.');
}
</code></pre><h3>7.4.3 Admin Panel</h3><p><strong>Детальная информация для администратора:</strong></p><pre><code class="language-javascript">function showAdminError(error) {
  const errorDetails = {
    message: error.message,
    endpoint: error.config.url,
    status: error.response?.status,
    timestamp: new Date().toISOString(),
    trace: error.stack
  };
  
  console.error('Admin Error:', errorDetails);
  
  displayErrorModal({
    title: 'Ошибка выполнения запроса',
    details: errorDetails,
    actions: [
      { label: 'Повторить', onClick: () =&gt; retryRequest() },
      { label: 'Скопировать детали', onClick: () =&gt; copyToClipboard(errorDetails) },
      { label: 'Отправить в поддержку', onClick: () =&gt; sendToSupport(errorDetails) }
    ]
  });
}
</code></pre><h2>7.5 Рекомендации по обработке ошибок</h2><h3>7.5.1 Best Practices</h3><p><li><strong>Логируй всё важное, но не перегружай логи</strong></li>
   - DEBUG для разработки
   - INFO для production
   - ERROR всегда логировать</p><p><li><strong>Не раскрывай внутренние детали пользователям</strong></li>
   <pre><code class="language-python">   # ❌ Плохо
   return jsonify({'error': str(exception)})
   
   # ✅ Хорошо
   logger.error(f'Internal error: {exception}')
   return jsonify({'error': 'Произошла ошибка. Попробуйте позже.'})
   </code></pre><p><li><strong>Используй структурированное логирование</strong></li>
   <pre><code class="language-python">   logger.info('Payment created', extra={
       'payment_id': payment_id,
       'user_id': chat_id,
       'amount': price,
       'timestamp': datetime.now().isoformat()
   })
   </code></pre><p><li><strong>Централизуй обработку ошибок</strong></li>
   <pre><code class="language-python">   # Flask error handler
   @app.errorhandler(Exception)
   def handle_exception(e):
       logger.error(f'Unhandled exception: {e}', exc_info=True)
       return jsonify({
           'success': False,
           'error': 'Внутренняя ошибка сервера'
       }), 500
   </code></pre><p><li><strong>Мониторь критические метрики</strong></li>
   - Error rate (% ошибок от общего числа запросов)
   - Response time (время ответа)
   - Uptime (доступность сервиса)
   - API quotas (использование квот)</p>`
    },
    'deployment': {
        title: 'Развертывание',
        content: `<h1>8. Развертывание EventSummaryBot</h1><h2>8.1 Общая схема развертывания</h2><pre><code class="language-">┌────────────────────────────────────────────────────────────┐
│                     PRODUCTION ENVIRONMENT                 │
└────────────────────────────────────────────────────────────┘</p><p>┌─────────────────────┐      ┌──────────────────────────────┐
│   Cloud Platform    │      │     External Services         │
│   (VPS/Cloud)       │      │                              │
│                     │      │  • Telegram Bot API          │
│  ┌──────────────┐   │      │  • Whisper API               │
│  │   n8n        │◄──┼──────┤  • Anthropic Claude          │
│  │   Docker     │   │      │  • Zoom API                  │
│  └──────────────┘   │      │  • YooKassa                  │
│                     │      │  • Google Workspace          │
│  ┌──────────────┐   │      └──────────────────────────────┘
│  │   Flask      │   │
│  │   + Gunicorn │   │      ┌──────────────────────────────┐
│  │   Docker     │   │      │      Data Storage            │
│  └──────────────┘   │      │                              │
│                     │      │  • Google Sheets (Users)     │
│  ┌──────────────┐   │      │  • Google Sheets (Payments)  │
│  │   Nginx      │◄──┼──────┤  • Google Drive (Files)      │
│  │   Reverse    │   │      │  • Google Docs (Summaries)   │
│  │   Proxy      │   │      └──────────────────────────────┘
│  └──────────────┘   │
│                     │
│  ┌──────────────┐   │
│  │   SSL/TLS    │   │
│  │   Let's      │   │
│  │   Encrypt    │   │
│  └──────────────┘   │
└─────────────────────┘
</code></pre><h2>8.2 Типовая инфраструктура</h2><h3>8.2.1 Минимальная конфигурация</h3><p><strong>Для небольших проектов (< 100 пользователей):</strong></p><table>
<thead><tr><th>Компонент</th><th>Требования</th></tr></thead>
<tbody>
<tr><td><strong>CPU</strong></td><td>2 vCPU</td></tr>
<tr><td><strong>RAM</strong></td><td>4 GB</td></tr>
<tr><td><strong>Диск</strong></td><td>50 GB SSD</td></tr>
<tr><td><strong>ОС</strong></td><td>Ubuntu 22.04 LTS</td></tr>
<tr><td><strong>Сеть</strong></td><td>100 Mbps</td></tr>
</tbody></table><p><strong>Стоимость:</strong> ~15-25$/месяц (VPS)</p><p><strong>Провайдеры:</strong>
<ul><li>DigitalOcean Droplet</li>
<li>Hetzner Cloud</li>
<li>AWS EC2 t3.medium</li>
<li>Yandex Cloud</li>
</ul>
<h3>8.2.2 Рекомендуемая конфигурация</h3><p><strong>Для средних проектов (100-1000 пользователей):</strong></p><table>
<thead><tr><th>Компонент</th><th>Требования</th></tr></thead>
<tbody>
<tr><td><strong>CPU</strong></td><td>4 vCPU</td></tr>
<tr><td><strong>RAM</strong></td><td>8 GB</td></tr>
<tr><td><strong>Диск</strong></td><td>100 GB SSD</td></tr>
<tr><td><strong>ОС</strong></td><td>Ubuntu 22.04 LTS</td></tr>
<tr><td><strong>Сеть</strong></td><td>1 Gbps</td></tr>
</tbody></table><p><strong>Стоимость:</strong> ~40-60$/месяц</p><h3>8.2.3 Enterprise конфигурация</h3><p><strong>Для крупных проектов (> 1000 пользователей):</strong></p><table>
<thead><tr><th>Компонент</th><th>Требования</th></tr></thead>
<tbody>
<tr><td><strong>Сервер 1 (n8n)</strong></td><td>4 vCPU, 8 GB RAM</td></tr>
<tr><td><strong>Сервер 2 (Flask)</strong></td><td>4 vCPU, 8 GB RAM</td></tr>
<tr><td><strong>Load Balancer</strong></td><td>Managed LB</td></tr>
<tr><td><strong>База данных</strong></td><td>Separate database server</td></tr>
<tr><td><strong>Object Storage</strong></td><td>S3/Cloud Storage</td></tr>
<tr><td><strong>CDN</strong></td><td>CloudFlare/Fastly</td></tr>
</tbody></table><p><strong>Стоимость:</strong> ~150-300$/месяц</p><h2>8.3 Развертывание n8n</h2><h3>8.3.1 Установка через Docker</h3><p><strong>docker-compose.yml для n8n:</strong></p><pre><code class="language-yaml">version: '3.8'</p><p>services:
  n8n:
    image: n8nio/n8n:latest
    container_name: n8n
    restart: unless-stopped
    ports:
      - "5678:5678"
    environment:
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=\${N8N_PASSWORD}
      - N8N_HOST=\${N8N_HOST}
      - N8N_PORT=5678
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - WEBHOOK_URL=https://\${N8N_HOST}/
      - GENERIC_TIMEZONE=Europe/Moscow
      - N8N_LOG_LEVEL=info
      - N8N_LOG_OUTPUT=console,file
      - N8N_LOG_FILE_LOCATION=/home/node/.n8n/logs/
    volumes:
      - n8n_data:/home/node/.n8n
      - ./n8n_workflows:/home/node/.n8n/workflows
    networks:
      - n8n-network</p><p>volumes:
  n8n_data:</p><p>networks:
  n8n-network:
    driver: bridge
</code></pre><p><strong>Переменные окружения (.env):</strong></p><pre><code class="language-bash"># n8n Configuration
N8N_HOST=n8n.yourdomain.com
N8N_PASSWORD=SecurePassword123!</p><h1>Telegram Bot</h1>
TELEGRAM_BOT_TOKEN=your_bot_token</p><h1>Whisper API</h1>
WHISPER_API_KEY=your_whisper_key</p><h1>Anthropic Claude</h1>
ANTHROPIC_API_KEY=your_anthropic_key</p><h1>Zoom</h1>
ZOOM_CLIENT_ID=your_zoom_client_id
ZOOM_CLIENT_SECRET=your_zoom_client_secret</p><h1>Google</h1>
GOOGLE_SERVICE_ACCOUNT_EMAIL=your_service_account@project.iam.gserviceaccount.com
GOOGLE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
GOOGLE_SHEET_ID=your_sheet_id
</code></pre><p><strong>Запуск:</strong></p><pre><code class="language-bash"># Создание директории для n8n
mkdir -p ~/n8n_data
mkdir -p ~/n8n_workflows</p><h1>Запуск контейнера</h1>
docker-compose up -d n8n</p><h1>Проверка логов</h1>
docker logs -f n8n</p><h1>Проверка статуса</h1>
docker ps | grep n8n
</code></pre><h3>8.3.2 Импорт workflows</h3><pre><code class="language-bash"># Копирование workflow файлов
cp eventsummarybotn8nworkflows/*.json ~/n8n_workflows/</p><h1>Рестарт n8n для загрузки workflows</h1>
docker-compose restart n8n</p><h1>Альтернатива: импорт через UI</h1>
<h1>1. Открыть https://n8n.yourdomain.com</h1>
<h1>2. Settings → Workflows</h1>
<h1>3. Import from file</h1>
</code></pre><h3>8.3.3 Настройка Credentials</h3><p><strong>В UI n8n (Credentials):</strong></p><p><li><strong>Telegram</strong></li>
   - Type: Telegram API
   - Access Token: <code>[TELEGRAM_BOT_TOKEN]</code></p><p><li><strong>Anthropic</strong></li>
   - Type: Anthropic API
   - API Key: <code>[ANTHROPIC_API_KEY]</code></p><p><li><strong>Google Sheets</strong></li>
   - Type: Google Sheets OAuth2 API
   - Service Account Email: <code>[GOOGLE_SERVICE_ACCOUNT_EMAIL]</code>
   - Private Key: <code>[GOOGLE_PRIVATE_KEY]</code></p><p><li><strong>Zoom</strong></li>
   - Type: Zoom OAuth2 API
   - Client ID: <code>[ZOOM_CLIENT_ID]</code>
   - Client Secret: <code>[ZOOM_CLIENT_SECRET]</code>
   - Authorization URL: <code>https://zoom.us/oauth/authorize</code>
   - Access Token URL: <code>https://zoom.us/oauth/token</code></p><p><li><strong>YooKassa</strong> (в Flask, но может понадобиться для тестирования)</li>
   - Type: HTTP Request
   - Authentication: Basic Auth
   - User: <code>[YOOKASSA_SHOP_ID]</code>
   - Password: <code>[YOOKASSA_SECRET_KEY]</code></p><h2>8.4 Развертывание Flask приложения</h2><h3>8.4.1 Dockerfile</h3><p><strong>eventsummarybotsite/Dockerfile:</strong></p><pre><code class="language-dockerfile">FROM python:3.11-slim</p><h1>Установка системных зависимостей</h1>
RUN apt-get update &amp;&amp; apt-get install -y \
    gcc \
    curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*</p><h1>Создание рабочей директории</h1>
WORKDIR /app</p><h1>Копирование requirements</h1>
COPY requirements.txt .</p><h1>Установка Python зависимостей</h1>
RUN pip install --no-cache-dir -r requirements.txt</p><h1>Копирование приложения</h1>
COPY . .</p><h1>Создание директории для логов</h1>
RUN mkdir -p /app/logs</p><h1>Открытие порта</h1>
EXPOSE 3000</p><h1>Health check</h1>
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1</p><h1>Запуск через Gunicorn</h1>
CMD ["gunicorn", "--bind", "0.0.0.0:3000", "--workers", "4", "--timeout", "120", "wsgi:app"]
</code></pre><h3>8.4.2 docker-compose.yml</h3><p><strong>eventsummarybotsite/docker-compose.yml:</strong></p><pre><code class="language-yaml">version: '3.8'</p><p>services:
  payment_app:
    build: .
    container_name: eventsummary_flask
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - FLASK_ENV=production
      - PORT=3000
      - ALLOWED_ORIGINS=https://yourdomain.com,https://t.me
      - JWT_SECRET=\${JWT_SECRET}
      
      # Google
      - GOOGLE_SHEET_ID=\${GOOGLE_SHEET_ID}
      - GOOGLE_SERVICE_ACCOUNT_EMAIL=\${GOOGLE_SERVICE_ACCOUNT_EMAIL}
      - GOOGLE_PRIVATE_KEY=\${GOOGLE_PRIVATE_KEY}
      
      # YooKassa
      - YOOKASSA_SHOP_ID=\${YOOKASSA_SHOP_ID}
      - YOOKASSA_SECRET_KEY=\${YOOKASSA_SECRET_KEY}
      - YOOKASSA_RETURN_URL=https://t.me/EventSummaryBot
      
      # Telegram
      - TELEGRAM_BOT_TOKEN=\${TELEGRAM_BOT_TOKEN}
    
    volumes:
      - ./logs:/app/logs
      - ./.env:/app/.env:ro
    
    networks:
      - app-network
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s</p><p>networks:
  app-network:
    driver: bridge
</code></pre><p><strong>Запуск:</strong></p><pre><code class="language-bash">cd eventsummarybotsite</p><h1>Сборка образа</h1>
docker-compose build</p><h1>Запуск контейнера</h1>
docker-compose up -d</p><h1>Проверка логов</h1>
docker-compose logs -f payment_app</p><h1>Проверка health</h1>
curl http://localhost:3000/health
</code></pre><h2>8.5 Настройка Nginx</h2><h3>8.5.1 Конфигурация для n8n</h3><p><strong>/etc/nginx/sites-available/n8n.conf:</strong></p><pre><code class="language-nginx">server {
    listen 80;
    server_name n8n.yourdomain.com;
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}</p><p>server {
    listen 443 ssl http2;
    server_name n8n.yourdomain.com;
    
    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/n8n.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/n8n.yourdomain.com/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # Logging
    access_log /var/log/nginx/n8n_access.log;
    error_log /var/log/nginx/n8n_error.log;
    
    # Proxy to n8n
    location / {
        proxy_pass http://localhost:5678;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 300;
        proxy_send_timeout 300;
        proxy_read_timeout 300;
    }
}
</code></pre><h3>8.5.2 Конфигурация для Flask API</h3><p><strong>/etc/nginx/sites-available/api.conf:</strong></p><pre><code class="language-nginx">upstream flask_app {
    server localhost:3000;
    keepalive 64;
}</p><p>server {
    listen 80;
    server_name api.yourdomain.com;
    
    return 301 https://$server_name$request_uri;
}</p><p>server {
    listen 443 ssl http2;
    server_name api.yourdomain.com;
    
    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/api.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.yourdomain.com/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    
    # Security Headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Logging
    access_log /var/log/nginx/api_access.log;
    error_log /var/log/nginx/api_error.log;
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    
    # API endpoints
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        
        proxy_pass http://flask_app;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Connection "";
        
        # CORS
        add_header Access-Control-Allow-Origin "https://t.me" always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Content-Type, Authorization" always;
        
        if ($request_method = 'OPTIONS') {
            return 204;
        }
    }
    
    # Static files (frontend)
    location / {
        proxy_pass http://flask_app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # Health check
    location /health {
        proxy_pass http://flask_app/health;
        access_log off;
    }
}
</code></pre><p><strong>Активация конфигураций:</strong></p><pre><code class="language-bash"># Создание символических ссылок
sudo ln -s /etc/nginx/sites-available/n8n.conf /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/api.conf /etc/nginx/sites-enabled/</p><h1>Проверка конфигурации</h1>
sudo nginx -t</p><h1>Перезагрузка Nginx</h1>
sudo systemctl reload nginx
</code></pre><h2>8.6 SSL/TLS сертификаты</h2><h3>8.6.1 Установка Let's Encrypt</h3><pre><code class="language-bash"># Установка Certbot
sudo apt update
sudo apt install certbot python3-certbot-nginx</p><h1>Получение сертификатов</h1>
sudo certbot --nginx -d n8n.yourdomain.com
sudo certbot --nginx -d api.yourdomain.com</p><h1>Автоматическое обновление</h1>
sudo systemctl status certbot.timer</p><h1>Тест обновления</h1>
sudo certbot renew --dry-run
</code></pre><h2>8.7 Мониторинг и логирование</h2><h3>8.7.1 Настройка Prometheus + Grafana (опционально)</h3><p><strong>docker-compose-monitoring.yml:</strong></p><pre><code class="language-yaml">version: '3.8'</p><p>services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    networks:
      - monitoring</p><p>  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - monitoring</p><p>volumes:
  prometheus_data:
  grafana_data:</p><p>networks:
  monitoring:
    driver: bridge
</code></pre><p><strong>prometheus.yml:</strong></p><pre><code class="language-yaml">global:
  scrape_interval: 15s</p><p>scrape_configs:
  - job_name: 'n8n'
    static_configs:
      - targets: ['n8n:5678']
  
  - job_name: 'flask'
    static_configs:
      - targets: ['payment_app:3000']
  
  - job_name: 'node_exporter'
    static_configs:
      - targets: ['node_exporter:9100']
</code></pre><h2>8.8 Backup и восстановление</h2><h3>8.8.1 Резервное копирование n8n</h3><pre><code class="language-bash">#!/bin/bash
<h1>backup_n8n.sh</h1><p>BACKUP_DIR="/backups/n8n"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="n8n_backup_\${DATE}.tar.gz"</p><h1>Создание директории</h1>
mkdir -p $BACKUP_DIR</p><h1>Копирование данных n8n</h1>
docker exec n8n tar czf /tmp/n8n_data.tar.gz /home/node/.n8n
docker cp n8n:/tmp/n8n_data.tar.gz $BACKUP_DIR/$BACKUP_FILE</p><h1>Удаление старых бэкапов (&gt; 30 дней)</h1>
find $BACKUP_DIR -name "n8n_backup_*.tar.gz" -mtime +30 -delete</p><p>echo "Backup created: $BACKUP_FILE"
</code></pre><h3>8.8.2 Резервное копирование Flask</h3><pre><code class="language-bash">#!/bin/bash
<h1>backup_flask.sh</h1><p>BACKUP_DIR="/backups/flask"
DATE=$(date +%Y%m%d_%H%M%S)</p><p>mkdir -p $BACKUP_DIR</p><h1>Копирование логов</h1>
tar czf $BACKUP_DIR/logs_\${DATE}.tar.gz /app/logs</p><h1>Экспорт переменных окружения (без чувствительных данных)</h1>
docker exec eventsummary_flask env | grep -v 'SECRET\|KEY\|PASSWORD' &gt; $BACKUP_DIR/env_\${DATE}.txt</p><p>echo "Flask backup created"
</code></pre><h3>8.8.3 Резервное копирование Google Sheets</h3><p><strong>Автоматический скрипт:</strong></p><pre><code class="language-python"># backup_sheets.py
import gspread
from google.oauth2.service_account import Credentials
import json
from datetime import datetime</p><p>def backup_google_sheets():
    # Аутентификация
    creds = Credentials.from_service_account_file(
        'credentials.json',
        scopes=['https://www.googleapis.com/auth/spreadsheets.readonly']
    )
    client = gspread.authorize(creds)
    
    # Открытие таблицы
    sheet = client.open_by_key(SHEET_ID)
    
    # Бэкап всех листов
    backup_data = {}
    for worksheet in sheet.worksheets():
        backup_data[worksheet.title] = worksheet.get_all_records()
    
    # Сохранение в файл
    backup_file = f'sheets_backup_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
    with open(f'/backups/sheets/{backup_file}', 'w', encoding='utf-8') as f:
        json.dump(backup_data, f, ensure_ascii=False, indent=2)
    
    print(f'Sheets backup created: {backup_file}')</p><p>if __name__ == '__main__':
    backup_google_sheets()
</code></pre><p><strong>Cron job:</strong></p><pre><code class="language-bash"># Ежедневный бэкап в 3:00
0 3 * * * /usr/bin/python3 /scripts/backup_sheets.py
</code></pre><h2>8.9 CI/CD Pipeline (опционально)</h2><h3>8.9.1 GitHub Actions</h3><p><strong>.github/workflows/deploy.yml:</strong></p><pre><code class="language-yaml">name: Deploy EventSummaryBot</p><p>on:
  push:
    branches: [ main ]</p><p>jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Build Flask Docker Image
      run: |
        cd eventsummarybotsite
        docker build -t eventsummarybot:latest .
    
    - name: Deploy to Server
      uses: appleboy/ssh-action@master
      with:
        host: \${{ secrets.SERVER_HOST }}
        username: \${{ secrets.SERVER_USER }}
        key: \${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          cd /opt/eventsummarybot
          git pull origin main
          docker-compose down
          docker-compose up -d --build
          docker system prune -f
</code></pre><h2>8.10 Checklist развертывания</h2><h3>8.10.1 Pre-deployment</h3><ul><li>[ ] Создан VPS/Cloud сервер</li>
<li>[ ] Настроены DNS записи (A records)</li>
<li>[ ] Установлен Docker и Docker Compose</li>
<li>[ ] Настроен firewall (UFW/iptables)</li>
<li>[ ] Созданы все необходимые аккаунты (Telegram Bot, Google, YooKassa)</li>
<li>[ ] Получены все API ключи</li>
<li>[ ] Подготовлены .env файлы</li>
</ul>
<h3>8.10.2 Deployment</h3><ul><li>[ ] Развернут n8n</li>
<li>[ ] Импортированы workflows</li>
<li>[ ] Настроены credentials в n8n</li>
<li>[ ] Развернуто Flask приложение</li>
<li>[ ] Настроен Nginx</li>
<li>[ ] Получены SSL сертификаты</li>
<li>[ ] Настроены webhooks (Telegram, Zoom, YooKassa)</li>
<li>[ ] Проверена работоспособность всех эндпоинтов</li>
</ul>
<h3>8.10.3 Post-deployment</h3><ul><li>[ ] Настроен мониторинг</li>
<li>[ ] Настроено резервное копирование</li>
<li>[ ] Протестированы основные сценарии</li>
<li>[ ] Созданы алерты для критических событий</li>
<li>[ ] Документированы credentials и доступы</li>
<li>[ ] Проведено нагрузочное тестирование (опционально)</li>
</ul>`
    },
    'scalability': {
        title: 'Масштабирование',
        content: `<h1>9. Масштабирование и безопасность</h1><h2>9.1 Масштабирование</h2><h3>9.1.1 Горизонтальное масштабирование</h3><p>EventSummaryBot спроектирован для горизонтального масштабирования, позволяющего обрабатывать растущую нагрузку путём добавления новых серверов.</p><h4>Архитектура с Load Balancer</h4><pre><code class="language-">                    ┌──────────────────┐
                    │   Load Balancer  │
                    │   (Nginx/HAProxy)│
                    └────────┬─────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
            ▼                ▼                ▼
    ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
    │  Flask App   │ │  Flask App   │ │  Flask App   │
    │  Instance 1  │ │  Instance 2  │ │  Instance 3  │
    └──────┬───────┘ └──────┬───────┘ └──────┬───────┘
           │                │                │
           └────────────────┼────────────────┘
                            │
                    ┌───────▼─────────┐
                    │  Google Sheets  │
                    │  (Shared State) │
                    └─────────────────┘
</code></pre><p><strong>Nginx Load Balancer Configuration:</strong></p><pre><code class="language-nginx">upstream flask_cluster {
    least_conn;  # Балансировка по минимальному количеству соединений
    
    server 10.0.1.10:3000 max_fails=3 fail_timeout=30s;
    server 10.0.1.11:3000 max_fails=3 fail_timeout=30s;
    server 10.0.1.12:3000 max_fails=3 fail_timeout=30s;
    
    keepalive 32;
}</p><p>server {
    listen 443 ssl http2;
    server_name api.yourdomain.com;
    
    location /api/ {
        proxy_pass http://flask_cluster;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Health check
        proxy_next_upstream error timeout http_502 http_503 http_504;
    }
}
</code></pre><h3>9.1.2 Вертикальное масштабирование</h3><p><strong>Scaling Guidelines:</strong></p><table>
<thead><tr><th>Метрика</th><th>Действие</th></tr></thead>
<tbody>
<tr><td><strong>CPU > 80%</strong></td><td>Увеличить количество vCPU или добавить инстансы</td></tr>
<tr><td><strong>RAM > 85%</strong></td><td>Увеличить RAM или оптимизировать приложение</td></tr>
<tr><td><strong>Disk I/O High</strong></td><td>Использовать SSD или добавить кэширование</td></tr>
<tr><td><strong>Network Bandwidth</strong></td><td>Upgrade тарифа или использовать CDN</td></tr>
</tbody></table><p><strong>Оптимизация Gunicorn:</strong></p><pre><code class="language-python"># wsgi.py
import multiprocessing</p><h1>Количество workers: (2 × CPU_cores) + 1</h1>
workers = multiprocessing.cpu_count() * 2 + 1</p><h1>Threads per worker</h1>
threads = 2</p><h1>Worker class</h1>
worker_class = 'gthread'  # Лучше для I/O bound операций</p><h1>Max requests per worker (предотвращает утечки памяти)</h1>
max_requests = 1000
max_requests_jitter = 50</p><h1>Timeouts</h1>
timeout = 120  # Для долгих операций (транскрибация)
graceful_timeout = 30</p><h1>Logging</h1>
accesslog = '/app/logs/gunicorn_access.log'
errorlog = '/app/logs/gunicorn_error.log'
loglevel = 'info'
</code></pre><p><strong>Запуск с оптимизированными параметрами:</strong></p><pre><code class="language-bash">gunicorn --bind 0.0.0.0:3000 \
         --workers 9 \
         --threads 2 \
         --worker-class gthread \
         --max-requests 1000 \
         --timeout 120 \
         --graceful-timeout 30 \
         --access-logfile /app/logs/gunicorn_access.log \
         --error-logfile /app/logs/gunicorn_error.log \
         wsgi:app
</code></pre><h3>9.1.3 Кэширование</h3><h4>Redis для кэширования</h4><p><strong>docker-compose.yml с Redis:</strong></p><pre><code class="language-yaml">services:
  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    networks:
      - app-network</p><p>  flask_app:
    # ... существующая конфигурация
    environment:
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - redis</p><p>volumes:
  redis_data:
</code></pre><p><strong>Использование в Flask:</strong></p><pre><code class="language-python"># app/config/redis_config.py
import redis
import os
import json
from functools import wraps</p><p>redis_client = redis.Redis(
    host=os.getenv('REDIS_HOST', 'localhost'),
    port=int(os.getenv('REDIS_PORT', 6379)),
    db=0,
    decode_responses=True
)</p><p>def cache_result(ttl=300):
    """Decorator для кэширования результатов"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Генерация ключа кэша
            cache_key = f"{func.__name__}:{args}:{kwargs}"
            
            # Проверка кэша
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # Выполнение функции
            result = func(*args, **kwargs)
            
            # Сохранение в кэш
            redis_client.setex(cache_key, ttl, json.dumps(result))
            
            return result
        return wrapper
    return decorator</p><h1>Использование</h1>
@cache_result(ttl=600)  # Кэш на 10 минут
def get_user_by_chat_id(chat_id):
    # Дорогая операция чтения из Google Sheets
    return user_service.get_user_by_chat_id(chat_id)
</code></pre><h4>Кэширование на уровне Nginx</h4><pre><code class="language-nginx"># Кэширование статики
location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg)$ {
    expires 7d;
    add_header Cache-Control "public, immutable";
}</p><h1>Кэширование API responses</h1>
location /api/news {
    proxy_cache api_cache;
    proxy_cache_valid 200 10m;
    proxy_cache_key "$scheme$request_method$host$request_uri";
    add_header X-Cache-Status $upstream_cache_status;
    
    proxy_pass http://flask_app;
}
</code></pre><h3>9.1.4 Очереди для асинхронной обработки</h3><h4>Celery для фоновых задач</h4><p><strong>Установка:</strong></p><pre><code class="language-bash">pip install celery[redis]
</code></pre><p><strong>celery_config.py:</strong></p><pre><code class="language-python"># app/celery_config.py
from celery import Celery
import os</p><p>celery_app = Celery(
    'eventsummarybot',
    broker=f'redis://{os.getenv("REDIS_HOST")}:6379/0',
    backend=f'redis://{os.getenv("REDIS_HOST")}:6379/1'
)</p><p>celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='Europe/Moscow',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=3600,  # 1 час
    worker_prefetch_multiplier=1,
    worker_max_tasks_per_child=1000
)</p><h1>Задачи</h1>
@celery_app.task
def process_transcription(audio_url, chat_id):
    """Фоновая обработка транскрибации"""
    # Долгая операция транскрибации
    pass</p><p>@celery_app.task
def send_batch_notifications(user_ids, message):
    """Массовая рассылка уведомлений"""
    for user_id in user_ids:
        send_telegram_message(user_id, message)
</code></pre><p><strong>Запуск Celery worker:</strong></p><pre><code class="language-bash">celery -A app.celery_config:celery_app worker --loglevel=info --concurrency=4
</code></pre><h3>9.1.5 CDN для статических файлов</h3><p><strong>Использование CloudFlare:</strong></p><p><li>Добавить домен в CloudFlare</li>
<li>Настроить DNS</li>
<li>Включить Proxy (оранжевое облако)</li>
<li>Настроить Cache Rules</li></p><p><strong>Оптимизация для CDN:</strong></p><pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;link rel="stylesheet" href="https://cdn.yourdomain.com/static/style.css?v=1.2.3"&gt;
&lt;script src="https://cdn.yourdomain.com/static/app.js?v=1.2.3"&gt;&lt;/script&gt;
</code></pre><h3>9.1.6 Database Connection Pooling</h3><p><strong>Оптимизация gspread:</strong></p><pre><code class="language-python"># app/config/google_sheets.py
from functools import lru_cache
import time</p><p>class GoogleSheetsConfig:
    def __init__(self):
        self.doc = None
        self.sheet = None
        self._last_auth_time = 0
        self._auth_ttl = 3600  # Re-auth каждый час
    
    @lru_cache(maxsize=128)
    def get_cached_records(self, cache_key):
        """Кэширование записей с TTL"""
        return self.get_all_records_fixed()
    
    def get_sheet(self):
        """Переиспользование соединения"""
        current_time = time.time()
        
        if not self.is_authenticated or (current_time - self._last_auth_time) &gt; self._auth_ttl:
            self.authenticate()
            self._last_auth_time = current_time
        
        return self.sheet
</code></pre><h3>9.1.7 Метрики масштабируемости</h3><table>
<thead><tr><th>Метрика</th><th>Текущая</th><th>Целевая (после оптимизации)</th></tr></thead>
<tbody>
<tr><td><strong>Requests/sec</strong></td><td>50</td><td>500</td></tr>
<tr><td><strong>Response Time (p95)</strong></td><td>250ms</td><td>< 100ms</td></tr>
<tr><td><strong>Concurrent Users</strong></td><td>100</td><td>1000</td></tr>
<tr><td><strong>Transcription Queue</strong></td><td>10 min wait</td><td>< 2 min wait</td></tr>
<tr><td><strong>Database Queries/sec</strong></td><td>100</td><td>1000 (с кэшем)</td></tr>
</tbody></table><p>---</p><h2>9.2 Безопасность</h2><h3>9.2.1 Аутентификация и авторизация</h3><h4>JWT для мини-приложения</h4><p><strong>Генерация токена:</strong></p><pre><code class="language-python"># app/services/auth_service.py
import jwt
import datetime
import os</p><p>JWT_SECRET = os.getenv('JWT_SECRET')
JWT_ALGORITHM = 'HS256'
JWT_EXPIRATION_HOURS = 24</p><p>def generate_jwt_token(chat_id, username):
    """Генерация JWT токена"""
    payload = {
        'chat_id': chat_id,
        'username': username,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=JWT_EXPIRATION_HOURS),
        'iat': datetime.datetime.utcnow()
    }
    
    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
    return token</p><p>def verify_jwt_token(token):
    """Проверка JWT токена"""
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise Exception('Token expired')
    except jwt.InvalidTokenError:
        raise Exception('Invalid token')
</code></pre><p><strong>Middleware для проверки токена:</strong></p><pre><code class="language-python"># app/middleware/auth_middleware.py
from flask import request, jsonify
from functools import wraps
from app.services.auth_service import verify_jwt_token</p><p>def require_auth(f):
    """Decorator для защиты endpoints"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Получение токена из заголовка
        auth_header = request.headers.get('Authorization')
        
        if not auth_header:
            return jsonify({'success': False, 'error': 'Authorization required'}), 401
        
        try:
            # Формат: "Bearer &lt;token&gt;"
            token = auth_header.split(' ')[1]
            payload = verify_jwt_token(token)
            
            # Добавление данных пользователя в request
            request.user = payload
            
            return f(*args, **kwargs)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 401
    
    return decorated_function</p><h1>Использование</h1>
@app.route('/api/payments/user/&lt;chatid&gt;')
@require_auth
def get_user_payments(chatid):
    # Проверка, что пользователь запрашивает свои данные
    if request.user['chat_id'] != chatid:
        return jsonify({'success': False, 'error': 'Forbidden'}), 403
    
    # ...
</code></pre><h4>Admin Authentication</h4><p><strong>Bcrypt для хеширования паролей:</strong></p><pre><code class="language-python"># app/services/admin_auth_service.py
import bcrypt
import logging</p><p>logger = logging.getLogger(__name__)</p><p>def hash_password(password):
    """Хеширование пароля"""
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')</p><p>def verify_password(password, hashed):
    """Проверка пароля"""
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))</p><p>def login_admin(email, password):
    """Аутентификация администратора"""
    # Получение из Google Sheets
    admins = get_admins_from_sheets()
    
    for admin in admins:
        if admin['email'] == email:
            if verify_password(password, admin['password_hash']):
                logger.info(f'Admin logged in: {email}')
                return {
                    'success': True,
                    'token': generate_jwt_token(admin['admin_id'], email),
                    'admin': {
                        'email': email,
                        'role': admin['role']
                    }
                }
            else:
                logger.warning(f'Failed login attempt: {email}')
                return {'success': False, 'error': 'Invalid credentials'}
    
    return {'success': False, 'error': 'Admin not found'}
</code></pre><p><strong>Rate Limiting для защиты от brute force:</strong></p><pre><code class="language-python"># app/middleware/rate_limiter.py
from flask import request, jsonify
from functools import wraps
import time</p><h1>Простой in-memory rate limiter (для production использовать Redis)</h1>
login_attempts = {}</p><p>def rate_limit_login(max_attempts=5, window=300):  # 5 попыток за 5 минут
    """Rate limiting для логина"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            ip = request.remote_addr
            current_time = time.time()
            
            # Очистка старых записей
            if ip in login_attempts:
                login_attempts[ip] = [t for t in login_attempts[ip] if current_time - t &lt; window]
            else:
                login_attempts[ip] = []
            
            # Проверка лимита
            if len(login_attempts[ip]) &gt;= max_attempts:
                return jsonify({
                    'success': False,
                    'error': f'Too many login attempts. Try again in {window//60} minutes.'
                }), 429
            
            # Добавление попытки
            login_attempts[ip].append(current_time)
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator</p><h1>Использование</h1>
@app.route('/api/auth/login', methods=['POST'])
@rate_limit_login(max_attempts=5, window=300)
def admin_login():
    # ...
</code></pre><h3>9.2.2 Защита API</h3><h4>Input Validation</h4><p><strong>Sanitization:</strong></p><pre><code class="language-python"># app/utils/validation.py
import re
import html</p><p>def sanitize_input(text, max_length=1000):
    """Очистка пользовательского ввода"""
    if not text:
        return ''
    
    # Обрезка длины
    text = text[:max_length]
    
    # Escape HTML
    text = html.escape(text)
    
    # Удаление опасных символов
    text = re.sub(r'[&lt;&gt;\"\'\`]', '', text)
    
    return text.strip()</p><p>def validate_email(email):
    """Валидация email"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None</p><p>def validate_url(url):
    """Валидация URL"""
    pattern = r'^https?://[^\s&lt;&gt;\"]+$'
    return re.match(pattern, url) is not None
</code></pre><h4>CORS Configuration</h4><pre><code class="language-python"># main.py
from flask_cors import CORS</p><h1>Строгая CORS политика</h1>
CORS(app, 
     origins=[
         'https://yourdomain.com',
         'https://t.me',
         'https://web.telegram.org'
     ],
     methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
     allow_headers=['Content-Type', 'Authorization'],
     supports_credentials=True,
     max_age=3600
)
</code></pre><h4>SQL Injection Protection</h4><p>Хотя система использует Google Sheets, важно защищаться от injection-атак:</p><pre><code class="language-python">def get_user_by_chatid_safe(chat_id):
    """Безопасный поиск пользователя"""
    # Валидация входных данных
    if not str(chat_id).isdigit():
        raise ValueError('Invalid chat_id format')
    
    chat_id_str = str(chat_id)
    
    # Использование параметризированных запросов (если бы использовали SQL)
    # В случае с Google Sheets - строгая валидация
    rows = google_sheets_config.get_all_records_fixed()
    
    for row in rows:
        if str(row.get('chatid')) == chat_id_str:
            return row
    
    return None
</code></pre><h3>9.2.3 Защита данных</h3><h4>Шифрование чувствительных данных</h4><pre><code class="language-python"># app/utils/encryption.py
from cryptography.fernet import Fernet
import os
import base64</p><p>class DataEncryption:
    def __init__(self):
        # Ключ шифрования из переменной окружения
        key = os.getenv('ENCRYPTION_KEY')
        if not key:
            # Генерация нового ключа (один раз)
            key = Fernet.generate_key()
            print(f'Generated encryption key: {key.decode()}')
        else:
            key = key.encode()
        
        self.cipher = Fernet(key)
    
    def encrypt(self, data):
        """Шифрование данных"""
        if isinstance(data, str):
            data = data.encode()
        encrypted = self.cipher.encrypt(data)
        return base64.b64encode(encrypted).decode()
    
    def decrypt(self, encrypted_data):
        """Расшифровка данных"""
        decoded = base64.b64decode(encrypted_data)
        decrypted = self.cipher.decrypt(decoded)
        return decrypted.decode()</p><h1>Singleton</h1>
encryption = DataEncryption()</p><h1>Использование для sensitive data</h1>
encrypted_token = encryption.encrypt(user_token)
<h1>Сохранение encrypted_token в БД</h1><h1>При получении</h1>
decrypted_token = encryption.decrypt(encrypted_token)
</code></pre><h4>Безопасное хранение credentials</h4><p><strong>Использование Environment Variables:</strong></p><pre><code class="language-bash"># .env (НЕ коммитить в Git!)
TELEGRAM_BOT_TOKEN=your_token_here
ANTHROPIC_API_KEY=your_key_here
YOOKASSA_SECRET_KEY=your_secret_here
GOOGLE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
JWT_SECRET=randomly_generated_secret_minimum_32_chars
ENCRYPTION_KEY=fernet_key_generated_once
</code></pre><p><strong>.gitignore:</strong></p><pre><code class="language-"># Environment
.env
.env.local
.env.production</p><h1>Credentials</h1>
credentials.json
service_account.json</p><h1>Secrets</h1>
secrets/
*.key
*.pem
</code></pre><p><strong>Docker Secrets (для Swarm/Kubernetes):</strong></p><pre><code class="language-yaml"># docker-compose.yml
version: '3.8'</p><p>services:
  flask_app:
    image: eventsummarybot:latest
    secrets:
      - telegram_token
      - anthropic_key
      - jwt_secret
    environment:
      - TELEGRAM_BOT_TOKEN_FILE=/run/secrets/telegram_token</p><p>secrets:
  telegram_token:
    external: true
  anthropic_key:
    external: true
  jwt_secret:
    external: true
</code></pre><h3>9.2.4 Network Security</h3><h4>Firewall (UFW)</h4><pre><code class="language-bash"># Базовая настройка
sudo ufw default deny incoming
sudo ufw default allow outgoing</p><h1>Разрешить SSH</h1>
sudo ufw allow 22/tcp</p><h1>Разрешить HTTP/HTTPS</h1>
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp</p><h1>Разрешить только с определённых IP (опционально)</h1>
sudo ufw allow from 192.168.1.0/24 to any port 22</p><h1>Включение firewall</h1>
sudo ufw enable
</code></pre><h4>DDoS Protection</h4><p><strong>Rate Limiting в Nginx:</strong></p><pre><code class="language-nginx"># /etc/nginx/nginx.conf
http {
    # Limit request rate
    limit_req_zone $binary_remote_addr zone=general:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    limit_req_zone $binary_remote_addr zone=api:10m rate=50r/s;
    
    # Limit connections
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;
    
    server {
        # General rate limit
        limit_req zone=general burst=20 nodelay;
        limit_conn conn_limit 10;
        
        # Login endpoint - строже
        location /api/auth/login {
            limit_req zone=login burst=5 nodelay;
        }
        
        # API endpoints
        location /api/ {
            limit_req zone=api burst=100 nodelay;
        }
    }
}
</code></pre><p><strong>Cloudflare DDoS Protection:</strong></p><p><li>Добавить сайт в Cloudflare</li>
<li>Security → DDoS → включить</li>
<li>Firewall Rules:</li>
   <pre><code class="language-">   Rule 1: Block traffic from bad bots
   (cf.threat_score &gt; 10)
   
   Rule 2: Challenge suspicious traffic
   (cf.threat_score &gt; 5)
   
   Rule 3: Rate limit API
   (http.request.uri.path contains "/api/")
   Rate: 100 requests per 10 seconds
   </code></pre><h3>9.2.5 Webhook Security</h3><h4>YooKassa Webhook Verification</h4><pre><code class="language-python"># app/controllers/payment_controller.py
import hmac
import hashlib</p><p>def verify_yookassa_signature(payload, signature):
    """Проверка подписи YooKassa webhook"""
    secret = os.getenv('YOOKASSA_SECRET_KEY')
    
    # Создание подписи
    computed_signature = hmac.new(
        secret.encode(),
        payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(computed_signature, signature)</p><p>@app.route('/api/payments/webhook', methods=['POST'])
def payment_webhook():
    # Получение подписи из заголовка
    signature = request.headers.get('X-Yookassa-Signature')
    
    if not signature:
        logger.warning('Webhook без подписи')
        return jsonify({'error': 'Missing signature'}), 401
    
    # Получение payload
    payload = request.get_data(as_text=True)
    
    # Проверка подписи
    if not verify_yookassa_signature(payload, signature):
        logger.error('Неверная подпись webhook')
        return jsonify({'error': 'Invalid signature'}), 401
    
    # Обработка webhook
    data = request.get_json()
    payment_service.handle_webhook(data)
    
    return jsonify({'success': True}), 200
</code></pre><h4>Telegram Bot Webhook Verification</h4><pre><code class="language-python">def verify_telegram_webhook(update_data, secret_token):
    """Проверка Telegram webhook"""
    expected_token = os.getenv('TELEGRAM_WEBHOOK_SECRET')
    
    if secret_token != expected_token:
        logger.warning('Invalid Telegram webhook token')
        return False
    
    return True
</code></pre><h3>9.2.6 Security Headers</h3><p><strong>Flask-Talisman для Security Headers:</strong></p><pre><code class="language-python"># main.py
from flask_talisman import Talisman</p><h1>Настройка безопасности</h1>
Talisman(app, 
    force_https=True,
    strict_transport_security=True,
    strict_transport_security_max_age=31536000,
    content_security_policy={
        'default-src': "'self'",
        'script-src': ["'self'", "'unsafe-inline'", 'https://telegram.org'],
        'style-src': ["'self'", "'unsafe-inline'"],
        'img-src': ["'self'", 'data:', 'https:'],
        'connect-src': ["'self'", 'https://api.yourdomain.com']
    },
    content_security_policy_nonce_in=['script-src'],
    feature_policy={
        'geolocation': "'none'",
        'microphone': "'none'",
        'camera': "'none'"
    }
)
</code></pre><p><strong>Альтернативно в Nginx:</strong></p><pre><code class="language-nginx"># Security headers
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;</p><h1>Content Security Policy</h1>
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' https://telegram.org; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://api.yourdomain.com" always;
</code></pre><h3>9.2.7 Security Checklist</h3><h4>Pre-Production</h4><ul><li>[ ] Все секреты в environment variables или secrets manager</li>
<li>[ ] Включен HTTPS с валидными сертификатами</li>
<li>[ ] Настроены security headers</li>
<li>[ ] Реализована аутентификация и авторизация</li>
<li>[ ] Валидация всех пользовательских данных</li>
<li>[ ] Rate limiting на всех endpoints</li>
<li>[ ] Webhook signature verification</li>
<li>[ ] Firewall настроен и активен</li>
<li>[ ] Disabled debug mode в production</li>
<li>[ ] Логирование без sensitive data</li>
</ul>
<h4>Post-Production</h4><ul><li>[ ] Регулярные security audits</li>
<li>[ ] Мониторинг подозрительной активности</li>
<li>[ ] Обновление зависимостей (security patches)</li>
<li>[ ] Резервное копирование данных</li>
<li>[ ] Incident response plan</li>
<li>[ ] Penetration testing (опционально)</li>
</ul>
<h3>9.2.8 Compliance</h3><h4>GDPR Considerations</h4><p>Если система работает с пользователями из ЕС:</p><p><li><strong>Право на удаление данных:</strong></li>
   <pre><code class="language-python">   @app.route('/api/users/&lt;chatid&gt;/delete', methods=['DELETE'])
   @require_auth
   def delete_user_data(chatid):
       """Удаление всех данных пользователя (GDPR)"""
       # Удаление из Google Sheets
       user_service.delete_user(chatid)
       # Удаление истории платежей
       payment_service.delete_user_payments(chatid)
       # Удаление файлов из Google Drive
       drive_service.delete_user_files(chatid)
       
       return jsonify({'success': True}), 200
   </code></pre><p><li><strong>Data Portability:</strong></li>
   <pre><code class="language-python">   @app.route('/api/users/&lt;chatid&gt;/export', methods=['GET'])
   @require_auth
   def export_user_data(chatid):
       """Экспорт всех данных пользователя"""
       data = {
           'user': user_service.get_user(chatid),
           'payments': payment_service.get_user_payments(chatid),
           'transcriptions': transcription_service.get_user_transcriptions(chatid)
       }
       
       return jsonify(data), 200, {
           'Content-Disposition': f'attachment; filename=user_{chatid}_data.json'
       }
   </code></pre><p><li><strong>Privacy Policy:</strong></li>
   - Чёткое описание сбора данных
   - Цели использования данных
   - Срок хранения данных
   - Права пользователей</p>`
    },
};

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadSection('overview');
            setupNavigation();
            setupThemeToggle();
            setupSearch();
            setupMobileMenu();
        });

        // Load section
        function loadSection(sectionId) {
            const section = sections[sectionId];
            if (!section) return;

            const contentArea = document.getElementById('contentArea');
            contentArea.innerHTML = section.content;

            // Update breadcrumb
            document.getElementById('currentSection').textContent = section.title;

            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.section === sectionId) {
                    item.classList.add('active');
                }
            });

            // Scroll to top
            document.querySelector('.main-content').scrollTop = 0;
        }

        // Navigation
        function setupNavigation() {
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    loadSection(this.dataset.section);
                    // Close mobile menu
                    document.getElementById('sidebar').classList.remove('open');
                });
            });
        }

        // Theme toggle
        function setupThemeToggle() {
            const toggle = document.getElementById('themeToggle');
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);

            toggle.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
            });
        }

        // Search
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.toLowerCase();
                document.querySelectorAll('.nav-item').forEach(item => {
                    const text = item.textContent.toLowerCase();
                    if (text.includes(query)) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = query ? 'none' : 'block';
                    }
                });
            });
        }

        // Mobile menu
        function setupMobileMenu() {
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.getElementById('sidebar');
            const mobileOverlay = document.getElementById('mobileOverlay');
            const navItems = document.querySelectorAll('.nav-item');

            // Toggle menu
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                const isOpen = sidebar.classList.contains('open');
                
                if (isOpen) {
                    closeMobileMenu();
                } else {
                    openMobileMenu();
                }
            });

            // Close on overlay click
            mobileOverlay.addEventListener('click', function() {
                closeMobileMenu();
            });

            // Close on navigation item click (mobile)
            navItems.forEach(item => {
                item.addEventListener('click', function() {
                    if (window.innerWidth <= 768) {
                        closeMobileMenu();
                    }
                });
            });

            // Close on click outside
            document.addEventListener('click', function(e) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    closeMobileMenu();
                }
            });

            // Prevent body scroll when menu is open
            function openMobileMenu() {
                sidebar.classList.add('open');
                mobileOverlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            function closeMobileMenu() {
                sidebar.classList.remove('open');
                mobileOverlay.classList.remove('active');
                document.body.style.overflow = '';
            }

            // Handle orientation change
            window.addEventListener('resize', function() {
                if (window.innerWidth > 768) {
                    closeMobileMenu();
                }
            });
        }
    </script>
</body>
</html>

